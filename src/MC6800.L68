000016B4 Starting Address
Assembler used: EASy68K Editor/Assembler v5.16.01
Created On: 6/1/2023 3:30:28 PM

00000000                             1  *----------------------------------------------------------------------------
00000000                             2  * Title      : 3B Disassembler
00000000                             3  * Written by : Memory Snipers: John Fadich,Abhishek Muthabatulla, Rod Hoda
00000000                             4  * Date       : 5/30/23
00000000                             5  * Description: A Motorola MC68000 Microprocessor Disassembler 
00000000                             6  *----------------------------------------------------------------------------
00001000                             7          ORG     $1000
00001000  =0000000D                  8  CR      EQU     $0D         ASCII: carriage return
00001000  =0000000A                  9  LF      EQU     $0A         ASCII: line feed
00001000  =00000009                 10  TB      EQU     $09         ASCII: horizontal tab
00001000  =00007000                 11  MNADDR  EQU     $7000       Min address (starting location of test memory)
00001000  =00FFFFFE                 12  MXADDR  EQU     $00FFFFFE   Max address (last location for memory - 1 word)
00001000                            13  
00001000                            14  GBUFF   DS.L    1           Pointer to next location in "Good buffer"
00001004                            15  SLOC    DS.B    80          Starting location storage
00001054                            16  ELOC    DS.B    80          Ending location storage
000010A4                            17  
000010A4                            18  *-----I/O Memory-----
000010A4                            19  NGBUFF  DS.L    1           Pointer to next location after the first displayed instruction
000010A8                            20  IOOPCD  DS.B    1           IO offset value for OPNAME, or FF if none
000010A9                            21  IOBDCD  DS.B    1           IO offset value for BAD OPNAME, or FF if none
000010AA                            22  IOSIZE  DS.B    1           IO size for OP code, or FF if none
000010AC                            23  IOADDR  DS.L    1           IO address value for instruction memory location
000010B0                            24  IOLC    DS.B    1           IO line counter for screen
000010B1                            25  IOBC    DS.B    1           IO BAD counter
000010B2                            26  
000010B2                            27  
000010B2                            28  * OP code name memory
000010B2                            29  * Example to display MULU:
000010B2                            30  *       LEA     OPNAME,A1
000010B2                            31  *       ADD.L   #$2D,A1
000010B2                            32  *       MOVE.B  #14,D0
000010B2                            33  *       TRAP    #15
000010B2                            34  *                NAME           DEC     HEX
000010B2= 4D 4F 56 45 00            35  OPNAME  DC.B    'MOVE',0        00      00
000010B7= 4D 4F 56 45 41 00         36          DC.B    'MOVEA',0       05      05
000010BD= 4D 4F 56 45 4D 00         37          DC.B    'MOVEM',0       11      0B
000010C3= 41 44 44 00               38          DC.B    'ADD',0         17      11
000010C7= 41 44 44 41 00            39          DC.B    'ADDA',0        21      15
000010CC= 41 44 44 51 00            40          DC.B    'ADDQ',0        26      1A
000010D1= 53 55 42 00               41          DC.B    'SUB',0         31      1F
000010D5= 53 55 42 41 00            42          DC.B    'SUBA',0        35      23
000010DA= 53 55 42 49 00            43          DC.B    'SUBI',0        40      28
000010DF= 4D 55 4C 55 00            44          DC.B    'MULU',0        45      2D
000010E4= 44 49 56 53 00            45          DC.B    'DIVS',0        50      32
000010E9= 4C 45 41 00               46          DC.B    'LEA',0         55      37
000010ED= 41 4E 44 00               47          DC.B    'AND',0         59      3B
000010F1= 4F 52 49 00               48          DC.B    'ORI',0         63      3F
000010F5= 45 4F 52 00               49          DC.B    'EOR',0         67      43
000010F9= 45 4F 52 49 00            50          DC.B    'EORI',0        71      47
000010FE= 4E 4F 54 00               51          DC.B    'NOT',0         76      4C
00001102= 41 53 4C 00               52          DC.B    'ASL',0         80      50
00001106= 4C 53 52 00               53          DC.B    'LSR',0         84      54
0000110A= 42 54 53 54 00            54          DC.B    'BTST',0        88      58
0000110F= 43 4D 50 00               55          DC.B    'CMP',0         93      5D
00001113= 43 4D 50 41 00            56          DC.B    'CMPA',0        97      61
00001118= 43 4D 50 49 00            57          DC.B    'CMPI',0        102     66
0000111D= 42 63 63 00               58          DC.B    'Bcc',0         107     6B
00001121= 42 45 51 00               59          DC.B    'BEQ',0         111     6F
00001125= 42 4C 54 00               60          DC.B    'BLT',0         115     73
00001129= 42 4E 45 00               61          DC.B    'BNE',0         119     77
0000112D= 42 48 49 00               62          DC.B    'BHI',0         123     7B
00001131= 4A 53 52 00               63          DC.B    'JSR',0         127     7F
00001135= 52 54 53 00               64          DC.B    'RTS',0         131     83
00001139= 44 41 54 41 00            65          DC.B    'DATA',0        135     87
0000113E= 4D 4F 56 45 51 00         66          DC.B    'MOVEQ',0       140     8C
00001144= 4C 53 4C 00               67          DC.B    'LSL',0         146     92
00001148= 41 53 52 00               68          DC.B    'ASR',0         150     96
0000114C= 41 44 44 49 00            69          DC.B    'ADDI',0        154     9A
00001151= 42 52 41 00               70          DC.B    'BRA',0         159     9F
00001155= 42 53 52 00               71          DC.B    'BSR',0         163     A3
00001159= 42 43 43 00               72          DC.B    'BCC',0         167     A7
0000115D= 42 43 53 00               73          DC.B    'BCS',0         171     AB
00001161= 42 56 43 00               74          DC.B    'BVC',0         175     AF
00001165= 42 56 53 00               75          DC.B    'BVS',0         179     B3
00001169= 42 50 4C 00               76          DC.B    'BPL',0         183     B7
0000116D= 42 4D 49 00               77          DC.B    'BMI',0         187     BB
00001171= 42 47 45 00               78          DC.B    'BGE',0         191     BF
00001175= 42 47 54 00               79          DC.B    'BGT',0         195     C3
00001179= 42 4C 45 00               80          DC.B    'BLE',0         199     C7
0000117D= 42 4C 53 00               81          DC.B    'BLS',0         203     CB
00001181= 41 4E 44 49 00            82          DC.B    'ANDI',0        207     CF
00001186= 53 55 42 51 00            83          DC.B    'SUBQ',0        212     D4
0000118B= 4A 4D 50 00               84          DC.B    'JMP',0         217     D9
0000118F= 52 54 45 00               85          DC.B    'RTE',0         221     DD
00001193= 52 54 44 00               86          DC.B    'RTD',0         225     E1
00001197= 52 54 52 00               87          DC.B    'RTR',0         229     E5
0000119B= 4E 4F 50 00               88          DC.B    'NOP',0         233     E9
0000119F= 4D 55 4C 53 00            89          DC.B    'MULS',0        237     ED
000011A4= 44 49 56 55 00            90          DC.B    'DIVU',0        242     F2
000011A9= 4F 52 00                  91          DC.B    'OR',0          247     F7
000011AC= 49 4C 4C 45 47 41 ...     92          DC.B    'ILLEGAL',0     250     FA
000011B4                            93  
000011B4                            94  
000011B4= 2E 42 00                  95  IOOPSZ  DC.B    '.B',0          0       00
000011B7= 2E 57 00                  96          DC.B    '.W',0          3       03
000011BA= 2E 4C 00                  97          DC.B    '.L',0          6,      06
000011BD= 20 20 00                  98          DC.B    '  ',0          9,      09
000011C0                            99  
000011C0                           100  *-----EA Memory------
000011C0                           101  DMD     DS.B    1               Destination mode
000011C1                           102  DRG     DS.B    1               Destination register
000011C2                           103  SMD     DS.B    1               Source mode
000011C3                           104  SRG     DS.B    1               Source register
000011C4                           105  RGMD    DS.B    1               Last register + mod (00REGMOD)
000011C5                           106  DIS     DS.B    1               Last displacement
000011C6                           107  
000011C6                           108  *--------------------
000011C6                           109  *                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
000011C6                           110  MSSG0                    
000011C6= 20 20 20 20 20 57 ...    111          DC.B    '     Welcome to 3B Disassembler. The following instructions will guide you',CR,LF
00001212= 20 20 20 20 20 74 ...    112          DC.B    '     through the steps in order to disassemble your code according to your',CR,LF
0000125E= 20 20 20 20 20 70 ...    113          DC.B    '     preferences. After which, you may press [BACKSPACE] if you would like',CR,LF
000012AA= 20 20 20 20 20 74 ...    114          DC.B    '     to restart the program. You may press 0 at any time, to quit.',CR,LF,CR,LF
000012F0= 20 54 68 65 20 66 ...    115          DC.B    ' The following inputs must be entered in HEX format, from 0x7000 to 0x00FFFFFE.',CR,LF,CR,LF,0
00001344= 20 45 6E 74 65 72 ...    116  MSSG1   DC.B    ' Enter the starting location of the code to be disassembled, or leave it blank',CR,LF
00001394= 20 66 6F 72 20 74 ...    117          DC.B    ' for the starting address: 0x',0
000013B2= 20 45 6E 74 65 72 ...    118  MSSG2   DC.B    ' Enter the ending location of the code to be disassembled, or leave it blank',CR,LF
00001400= 20 66 6F 72 20 74 ...    119          DC.B    ' for the ending address: 0x',0
0000141C= 20 50 6C 65 61 73 ...    120  MSSG3   DC.B    ' Please note that this program will automatically detect the end of the file if',CR,LF
0000146D= 20 61 6E 20 61 64 ...    121          DC.B    ' an address is out of range. You may now confirm your inputs before continuing.',CR,LF
000014BE= 20 20 20 20 20 20 ...    122          DC.B    '          Continue: [ENTER]      Restart: [BACKSPACE]      Quit: [0]',0
00001503= 50 72 65 73 73 20 ...    123  MSSG4   DC.B    'Press [ENTER] for the next page, or [CTRL] + [ENTER] for next line.',0
00001547= 59 6F 75 20 68 61 ...    124  MSSG5   DC.B    'You have reached the end of the program. Press any key to restart, or 0 to quit.',0
00001598= 7C 20 20 41 64 64 ...    125  HEADR   DC.B    '|  Address | --------Code-------- |    OP-Code    |          Operand           |',0
000015E9= 20 20 20 20 20 20 ...    126  ERR0    DC.B    '                     !!! The input address was too small !!!',0
00001626= 20 20 20 20 20 20 ...    127  ERR1    DC.B    '                     !!! The input address was too large !!!',0
00001663= 20 20 20 20 20 20 ...    128  BLANK   DC.B    '                                                                                ',0
000016B4                           129  *                XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
000016B4                           130  
000016B4                           131  
000016B4  11FC 0000 10B0           132  START   MOVE.B  #0,IOLC             Set line counter to 0
000016BA  11FC 0000 10B1           133          MOVE.B  #0,IOBC             Set bad counter to 0
000016C0  43F8 11C6                134          LEA     MSSG0,A1            Welcome message
000016C4  103C 000E                135          MOVE.B  #14,D0              Display A1 until NULL char
000016C8  4E4F                     136          TRAP    #15
000016CA  6000 02B6                137          BRA     PRMPT1              Branch to first prompt
000016CE                           138  
000016CE                           139  *-----------------------------------
000016CE                           140  *    Conversion & Comparison Methods
000016CE                           141  *-----------------------------------
000016CE                           142  
000016CE                           143  *
000016CE                           144  * Flag set / clear: Sets or clears the flag
000016CE                           145  *
000016CE                           146   
000016CE  44FC 0004                147  FLAGST  MOVE.W  #%100,CCR       Set the z-flag
000016D2  4E75                     148          RTS                     Return to caller
000016D4  44FC 0000                149  FLAGCL  MOVE.W  #%000,CCR       Clear the z-flg
000016D8  4E75                     150          RTS                     Return to caller
000016DA                           151  
000016DA                           152  *
000016DA                           153  * ASCII2HEX: Convert ASCII into HEX.
000016DA                           154  * Input ASCII from D0 output HEX to D1
000016DA                           155  *
000016DA                           156  
000016DA                           157  ASCII2HEX
000016DA  2200                     158          MOVE.L  D0,D1           Move the input to D1
000016DC  0441 3030                159          SUB     #$3030,D1       Convert last word
000016E0  4841                     160          SWAP    D1              Swap bytes
000016E2  0441 3030                161          SUB     #$3030,D1       Convert first word
000016E6  4841                     162          SWAP    D1              Restore order
000016E8                           163          
000016E8  2F02                     164          MOVE.L  D2,-(SP)        Push D2 on stack
000016EA  4282                     165          CLR.L   D2              
000016EC  143C 0003                166          MOVE.B  #3,D2           Set rotation count
000016F0                           167          
000016F0  6100 001A                168          BSR     A2H             Start loop
000016F4                           169          
000016F4  241F                     170          MOVE.L  (SP)+,D2        Restore D2
000016F6                           171                  
000016F6                           172                                * XAXBXCXD
000016F6  E919                     173          ROL.B   #4,D1           XAXBXCDX
000016F8  E949                     174          LSL.W   #4,D1           XAXBCDX0
000016FA  E159                     175          ROL.W   #8,D1           XAXBX0CD
000016FC  4841                     176          SWAP    D1              X0CDXAXB
000016FE  E919                     177          ROL.B   #4,D1           X0CDXABX
00001700  E949                     178          LSL.W   #4,D1           X0CDABX0
00001702  E189                     179          LSL.L   #8,D1           CDABX000
00001704  4241                     180          CLR.W   D1              CDAB0000
00001706  4841                     181          SWAP    D1              0000CDAB
00001708  E159                     182          ROL.W   #8,D1           0000ABCD
0000170A  4E75                     183          RTS                     Return to caller
0000170C                           184          
0000170C                           185          
0000170C                           186  A2H   * ASCII2HEX helper: Convert bytes that were > 30 to appropriate HEX value
0000170C  B23C 0011                187          CMP.B   #$11,D1         11 = A
00001710  6700 0032                188          BEQ     A2H11
00001714  B23C 0012                189          CMP.B   #$12,D1         12 = B
00001718  6700 0030                190          BEQ     A2H12
0000171C  B23C 0013                191          CMP.B   #$13,D1         13 = C
00001720  6700 002E                192          BEQ     A2H13
00001724  B23C 0014                193          CMP.B   #$14,D1         14 = D
00001728  6700 002C                194          BEQ     A2H14
0000172C  B23C 0015                195          CMP.B   #$15,D1         15 = E
00001730  6700 002A                196          BEQ     A2H15
00001734  B23C 0016                197          CMP.B   #$16,D1         16 = F
00001738  6700 0028                198          BEQ     A2H16
0000173C                           199          
0000173C                           200  A2HADV  * A2H conversion branch helper: Rotate to the next byte, and loop back to A2H until all bytes have been analyzed/converted
0000173C  E199                     201          ROL.L   #8,D1           Rotate 1st byte to the end
0000173E  51CA FFCC                202          DBRA    D2,A2H          If count is > 0, decrement and loop back to A2H
00001742  4E75                     203          RTS                     If count == 0, return to sub-routine
00001744                           204  
00001744                           205  * A2H conversion branches
00001744  123C 000A                206  A2H11   MOVE.B  #$A,D1
00001748  60F2                     207          BRA     A2HADV
0000174A  123C 000B                208  A2H12   MOVE.B  #$B,D1
0000174E  60EC                     209          BRA     A2HADV
00001750  123C 000C                210  A2H13   MOVE.B  #$C,D1
00001754  60E6                     211          BRA     A2HADV
00001756  123C 000D                212  A2H14   MOVE.B  #$D,D1
0000175A  60E0                     213          BRA     A2HADV
0000175C  123C 000E                214  A2H15   MOVE.B  #$E,D1
00001760  60DA                     215          BRA     A2HADV
00001762  123C 000F                216  A2H16   MOVE.B  #$F,D1
00001766  60D4                     217          BRA     A2HADV
00001768                           218  
00001768                           219  *
00001768                           220  * HEX2ASCII: Convert HEX into ASCII.
00001768                           221  * Input HEX from D0.W output ASCII to D1.L
00001768                           222  *
00001768                           223  
00001768                           224  HEX2ASCII
00001768  2200                     225          MOVE.L  D0,D1           Move the input to D1
0000176A                           226  
0000176A                           227                                * XXXXABCD
0000176A  4841                     228          SWAP    D1              ABCDXXXX
0000176C  4241                     229          CLR.W   D1              ABCD0000
0000176E  E999                     230          ROL.L   #4,D1           BCD0000A
00001770  E909                     231          LSL.B   #4,D1           BCD000A0
00001772  E159                     232          ROL.W   #8,D1           BCD0A000
00001774  E999                     233          ROL.L   #4,D1           CD0A000B
00001776  E159                     234          ROL.W   #8,D1           CD0A0B00
00001778  E999                     235          ROL.L   #4,D1           D0A0B00C
0000177A  E909                     236          LSL.B   #4,D1           D0A0B0C0
0000177C  E999                     237          ROL.L   #4,D1           0A0B0C0D
0000177E                           238  
0000177E  2F02                     239          MOVE.L  D2,-(SP)        Push D2 on stack
00001780  4282                     240          CLR.L   D2              
00001782  143C 0003                241          MOVE.B  #3,D2           Set rotation count
00001786  6100 0012                242          BSR     H2A             Start loop
0000178A  241F                     243          MOVE.L  (SP)+,D2        Restore D2
0000178C                           244  
0000178C  0641 3030                245          ADD     #$3030,D1       Convert last word
00001790  4841                     246          SWAP    D1              Swap bytes
00001792  0641 3030                247          ADD     #$3030,D1       Convert first word
00001796  4841                     248          SWAP    D1              Restore order
00001798  4E75                     249          RTS                     Return to caller
0000179A                           250          
0000179A                           251          
0000179A                           252  H2A   * ASCII2HEX helper: Convert bytes that were > 30 to appropriate HEX value
0000179A  B23C 000A                253          CMP.B   #$A,D1         A = 11
0000179E  6700 0032                254          BEQ     H2AA
000017A2  B23C 000B                255          CMP.B   #$B,D1         B = 12
000017A6  6700 0030                256          BEQ     H2AB
000017AA  B23C 000C                257          CMP.B   #$C,D1         C = 13
000017AE  6700 002E                258          BEQ     H2AC
000017B2  B23C 000D                259          CMP.B   #$D,D1         D = 14
000017B6  6700 002C                260          BEQ     H2AD
000017BA  B23C 000E                261          CMP.B   #$E,D1         E = 15
000017BE  6700 002A                262          BEQ     H2AE
000017C2  B23C 000F                263          CMP.B   #$F,D1         F = 16
000017C6  6700 0028                264          BEQ     H2AF
000017CA                           265          
000017CA                           266  H2AADV  * H2A conversion branch helper: Rotate to the next byte, and loop back to H2A until all bytes have been analyzed/converted
000017CA  E199                     267          ROL.L   #8,D1           Rotate 1st byte to the end
000017CC  51CA FFCC                268          DBRA    D2,H2A          If count is > 0, decrement and loop back to A2H
000017D0  4E75                     269          RTS                     If count == 0, return to sub-routine
000017D2                           270  
000017D2                           271  * H2A conversion branches
000017D2  123C 0011                272  H2AA    MOVE.B  #$11,D1
000017D6  60F2                     273          BRA     H2AADV
000017D8  123C 0012                274  H2AB    MOVE.B  #$12,D1
000017DC  60EC                     275          BRA     H2AADV
000017DE  123C 0013                276  H2AC    MOVE.B  #$13,D1
000017E2  60E6                     277          BRA     H2AADV
000017E4  123C 0014                278  H2AD    MOVE.B  #$14,D1
000017E8  60E0                     279          BRA     H2AADV
000017EA  123C 0015                280  H2AE    MOVE.B  #$15,D1
000017EE  60DA                     281          BRA     H2AADV
000017F0  123C 0016                282  H2AF    MOVE.B  #$16,D1
000017F4  60D4                     283          BRA     H2AADV
000017F6                           284  
000017F6                           285  
000017F6                           286  *
000017F6                           287  * Mask: Mask an input
000017F6                           288  * Input value from D0, input mask from D2, output masked value to D1
000017F6                           289  *
000017F6                           290  
000017F6  2200                     291  MASK    MOVE.L  D0,D1           Move the input to D1
000017F8  C282                     292          AND.L   D2,D1           Perform AND on input with the mask
000017FA  4E75                     293          RTS                     Return to caller
000017FC                           294  
000017FC                           295  *
000017FC                           296  * Test Mask: Test an input to a mask.
000017FC                           297  * Input value from D0, input mask from D2, and modify z-flag
000017FC                           298  *
000017FC                           299  
000017FC  2F01                     300  TSTMSK  MOVE.L  D1,-(SP)        Push D1 on stack
000017FE  61F6                     301          BSR     MASK            Mask the input
00001800  B481                     302          CMP.L   D1,D2           Test if the input matched the mask
00001802  6606                     303          BNE     *+8             If it didn't match, skip two lines
00001804  221F                     304          MOVE.L  (SP)+,D1        Restore D1
00001806  6000 FEC6                305          BRA     FLAGST          Set flag & return to caller
0000180A  221F                     306          MOVE.L  (SP)+,D1        Restore D1
0000180C  6000 FEC6                307          BRA     FLAGCL          Clear flag & return to caller
00001810                           308  
00001810                           309  *
00001810                           310  * Compare Mask: Strictly test an input to two masks allowing don't cares.
00001810                           311  * Input value from D0, input 1 mask from D2, input 0 mask from D3, and modify z-flag
00001810                           312  *
00001810                           313  
00001810  48E7 F800                314  CMPMSK  MOVEM.L D0-D4,-(SP)     Push D1-D4 on stack
00001814  2800                     315          MOVE.L  D0,D4           Copy input to D4
00001816  C082                     316          AND.L   D2,D0           AND 1 mask to input
00001818  B480                     317          CMP.L   D0,D2           Compare masked input to 1 mask
0000181A  6708                     318          BEQ     *+10            If it matched, skip two lines
0000181C  4CDF 001F                319          MOVEM.L (SP)+,D0-D4     If it didn't match, restore D1-D4
00001820  6000 FEB2                320          BRA     FLAGCL          Clear flag & return to caller
00001824  2004                     321          MOVE.L  D4,D0           Restore input
00001826  4680                     322          NOT.L   D0              !input
00001828  C083                     323          AND.L   D3,D0           AND 0 mask on input; effectively, NOR 0 mask to the input
0000182A  B680                     324          CMP.L   D0,D3           Compare masked input to 0 mask
0000182C  6608                     325          BNE     *+10            If it didn't match, skip to clear flag
0000182E  4CDF 001F                326          MOVEM.L (SP)+,D0-D4     If it matched, restore D1-D4
00001832  6000 FE9A                327          BRA     FLAGST          Set flag & return to caller
00001836  4CDF 001F                328          MOVEM.L (SP)+,D0-D4     Restore D1-D4
0000183A  6000 FE98                329          BRA     FLAGCL          Clear flag & return to caller
0000183E                           330  
0000183E                           331  *        
0000183E                           332  * Extract Mask: Test an input to a subsequent mask, and return the masked value in LSB format
0000183E                           333  * Input value from D0, input mask from D2, output value in D1
0000183E                           334  *
0000183E                           335  
0000183E  2F02                     336  EXTMSK  MOVE.L  D2,-(SP)        Push D2 on stack
00001840  2200                     337          MOVE.L  D0,D1           Move the input to D1
00001842  C282                     338          AND.L   D2,D1           Perform AND on input with the mask
00001844  0802 0000                339  EXTLP   BTST.L  #0,D2           Test the LSB of the mask for 0
00001848  6700 0006                340          BEQ     EXTADV          If it is 0, rotate the mask until it is 1
0000184C  241F                     341          MOVE.L  (SP)+,D2        Restore the mask
0000184E  4E75                     342          RTS                     Return to caller
00001850                           343          
00001850  E28A                     344  EXTADV  LSR.L   #1,D2           Rotate mask right by 1 bit
00001852  E299                     345          ROR.L   #1,D1           Rotate output in sync with mask
00001854  60EE                     346          BRA     EXTLP           Return to loop
00001856                           347  
00001856                           348  *
00001856                           349  * Display ASCII: Display the ASCII from D0.L to screen
00001856                           350  *
00001856  48E7 E000                351  DSPAX   MOVEM.L D0-D2,-(SP)     Push D0-D2
0000185A  2200                     352          MOVE.L  D0,D1
0000185C  6000 0044                353          BRA     DSPHST          Branch to DISPHX Start
00001860                           354  
00001860                           355  *
00001860                           356  * Display HEX Address: Display the hex from A1 according to the byte length in D2.L
00001860                           357  *
00001860                           358  
00001860  48E7 E040                359  DSPHXA  MOVEM.L D0-D2/A1,-(SP)  Push D0-D2, and A1 to stack
00001864  51CA 0006                360  DSPHXLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
00001868  6000 0016                361          BRA     DSPHXRT         If count is <= 0, branch to return
0000186C  1019                     362          MOVE.B  (A1)+,D0        Get HEX byte in D0, post-increment A1
0000186E  6100 FEF8                363          BSR     HEX2ASCII       Get ASCII in D1
00001872  E159                     364          ROL.W   #8,D1           Read first byte
00001874  103C 0006                365          MOVE.B  #6,D0           Display char from D1.B
00001878  4E4F                     366          TRAP    #15
0000187A  E159                     367          ROL.W   #8,D1           Read second byte
0000187C  4E4F                     368          TRAP    #15
0000187E  60E4                     369          BRA     DSPHXLP         Loop back
00001880  4CDF 0207                370  DSPHXRT MOVEM.L (SP)+,D0-D2/A1  Else, restore values
00001884  4E75                     371          RTS                     Return to caller
00001886                           372  
00001886                           373  
00001886                           374  *
00001886                           375  * Display HEX Byte: Display the hex from D0.B to screen
00001886                           376  *
00001886                           377  
00001886  48E7 C000                378  DSPHXB  MOVEM.L D0/D1,-(SP)     Push D0 and D1 to stack
0000188A  6100 FEDC                379          BSR     HEX2ASCII       Get ASCII in D1
0000188E  103C 0006                380          MOVE.B  #6,D0           Set trap #6 to read single char from D1.B
00001892  4E4F                     381          TRAP    #15
00001894  4CDF 0003                382          MOVEM.L (SP)+,D0/D1     Restore D0 and D1
00001898  4E75                     383          RTS                     Return to caller
0000189A                           384  
0000189A                           385  *
0000189A                           386  * Display HEX Word: Display the hex from D0.W to screen
0000189A                           387  *
0000189A                           388  
0000189A  48E7 E000                389  DSPHXW  MOVEM.L D0-D2,-(SP)     Push D0-D2 to stack
0000189E  6100 FEC8                390          BSR     HEX2ASCII       Get ASCII in D1
000018A2                           391  
000018A2  4282                     392  DSPHST  CLR.L   D2              
000018A4  143C 0003                393          MOVE.B  #3,D2           Set rotation count
000018A8  103C 0006                394          MOVE.B  #6,D0           Set trap #6 to read single char from D1.B
000018AC  6100 0008                395          BSR     DSPHADV         Start loop
000018B0                           396  
000018B0  4CDF 0007                397          MOVEM.L  (SP)+,D0-D2    Restore D0-D2
000018B4  4E75                     398          RTS                     Return to caller
000018B6                           399  
000018B6  E199                     400  DSPHADV ROL.L   #8,D1           Rotate bytes left
000018B8  4E4F                     401          TRAP    #15             Display char in D1.B
000018BA  51CA FFFA                402          DBRA    D2,DSPHADV      If count is > 0, decrement and loop back to DSPHADV
000018BE  4E75                     403          RTS                     If count == 0, return to sub-routine
000018C0                           404  
000018C0                           405  *
000018C0                           406  * Display HEX Long: Display the hex from D0.L to screen
000018C0                           407  *
000018C0                           408  
000018C0  4840                     409  DSPHXL  SWAP    D0              Swap first half to D0.W
000018C2  61D6                     410          BSR     DSPHXW          Display first half
000018C4  4840                     411          SWAP    D0              Swap lower half to D0.W
000018C6  61D2                     412          BSR     DSPHXW          Display lower half
000018C8  4E75                     413          RTS                     Return to caller
000018CA                           414  
000018CA                           415  *
000018CA                           416  * Display string: Displays string until NULL char
000018CA                           417  * Input string at A1, output length of string at D1.B
000018CA                           418  * Max length: 255
000018CA                           419  *
000018CA                           420          
000018CA  48E7 E040                421  DSPSTR  MOVEM.L D0-D2/A1,-(SP)  Push D0-D2, and A1 to stack
000018CE  243C 000000FF            422          MOVE.L  #255,D2         Set count to 255
000018D4  51CA 0006                423  DSPSTLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
000018D8  6000 0016                424          BRA     DSPSTRT         If count is <= 0, branch to return
000018DC  1019                     425          MOVE.B  (A1)+,D0        Get HEX byte in D0, post-increment A1
000018DE  B03C 0000                426          CMP.B   #0,D0           Check if byte is NULL char
000018E2  6700 000C                427          BEQ     DSPSTRT         If byte is NULL char, branch to return
000018E6  6100 FE80                428          BSR     HEX2ASCII       Else, get ASCII in D1
000018EA  6100 FF6A                429          BSR     DSPAX           Display ASCII
000018EE  60E4                     430          BRA     DSPSTLP         Loop back
000018F0  4482                     431  DSPSTRT NEG.L   D2              Negate count
000018F2  0682 000000FE            432          ADD.L   #254,D2         Add 254; effectively 255 - count - null byte
000018F8  4CDF 0003                433          MOVEM.L (SP)+,D0/D1     Restore D0 and D1
000018FC  1202                     434          MOVE.B  D2,D1           Move length to D1
000018FE  4CDF 0204                435          MOVEM.L (SP)+,D2/A1     Restore D2 and A1
00001902  4E75                     436          RTS                     Return to caller
00001904                           437  
00001904                           438  *
00001904                           439  * Display offset space: Display space according to offset length
00001904                           440  * Input offset length in D2.B
00001904                           441  *
00001904                           442  
00001904  48E7 E000                443  DSPOFS  MOVEM.L D0-D2,-(SP)     Push D0-D2 to stack
00001908                           444          * Ensure count is strictly in one byte
00001908  4280                     445          CLR.L   D0
0000190A  1002                     446          MOVE.B  D2,D0
0000190C  2400                     447          MOVE.L  D0,D2
0000190E  51CA 0006                448  DSPOFLP DBRA    D2,*+8          Decrement count; if count is > 0, do not branch to return
00001912  6000 000E                449          BRA     DSPOFRT         If count is <= 0, branch to return
00001916  103C 0006                450          MOVE.B  #6,D0           Display character
0000191A  123C 0020                451          MOVE.B  #' ',D1         Read space
0000191E  4E4F                     452          TRAP    #15
00001920  60EC                     453          BRA     DSPOFLP         Loop back
00001922  4CDF 0007                454  DSPOFRT MOVEM.L (SP)+,D0-D2     Restore D0-D2
00001926  4E75                     455          RTS                     Return to callr
00001928                           456  
00001928                           457          
00001928                           458  *--------------------
00001928                           459  *   I/O
00001928                           460  *--------------------
00001928                           461  
00001928                           462  *
00001928                           463  * Clear row: Clears the row specified in D1
00001928                           464  *
00001928                           465  
00001928  48A7 C040                466  CLRRW   MOVEM.W D0/D1/A1,-(SP)  Push D0, D1, and A1 to stack
0000192C  E159                     467          ROL.W   #8,D1           Move row to MSB
0000192E  4201                     468          CLR.B   D1              Set column to 0
00001930  E159                     469          ROL.W   #8,D1           Move row to LSB
00001932  103C 000B                470          MOVE.B  #11,D0          Position cursor at ROW/COL
00001936  4E4F                     471          TRAP    #15
00001938  43F8 1663                472          LEA     BLANK,A1        Read blank row
0000193C  103C 000E                473          MOVE.B  #14,D0          Display A1 until null
00001940  4E4F                     474          TRAP    #15
00001942  4C9F 0203                475          MOVEM.W (SP)+,D0/D1/A1  Restore D0, D1, and A1
00001946  4E75                     476          RTS                     Return to caller
00001948                           477  
00001948  43F8 15E9                478  ILL0    LEA     ERR0,A1         Starting location was too small
0000194C  103C 000E                479          MOVE.B  #14,D0
00001950  4E4F                     480          TRAP    #15
00001952  6000 002E                481          BRA     PRMPT1          Branch to prompt one
00001956                           482          
00001956  43F8 1626                483  ILL1    LEA     ERR1,A1         Starting location was too large
0000195A  103C 000E                484          MOVE.B  #14,D0
0000195E  4E4F                     485          TRAP    #15
00001960  6000 0020                486          BRA     PRMPT1          Branch to prompt one
00001964                           487  
00001964  103C 000B                488  ILL2    MOVE.B  #11,D0          Position cursor at COL/ROW
00001968  323C 1D14                489          MOVE.W  #$1D14,D1       Position after input location
0000196C  4E4F                     490          TRAP    #15
0000196E  203C 00007000            491          MOVE.L  #MNADDR,D0      Move min address to D0
00001974  6100 FF4A                492          BSR     DSPHXL          Display min address to screen
00001978  22BC 00007000            493          MOVE.L  #MNADDR,(A1)    Move the min address to SLOC
0000197E  6000 0090                494          BRA     PRMPT2          Branch to the next prompt
00001982                           495          
00001982  123C 0014                496  PRMPT1  MOVE.B  #$14,D1         Set row to $14
00001986  61A0                     497          BSR     CLRRW           Clear the row (if existing input is present)
00001988  103C 000B                498          MOVE.B  #11,D0          Position cursor at COL/ROW
0000198C  323C 0013                499          MOVE.W  #$0013,D1       Position
00001990  4E4F                     500          TRAP    #15
00001992                           501  
00001992  43F8 1344                502          LEA     MSSG1,A1        Starting location request message
00001996  103C 000E                503          MOVE.B  #14,D0
0000199A  4E4F                     504          TRAP    #15
0000199C                           505          
0000199C  43F8 1004                506          LEA     SLOC,A1         Input will be stored in SLOC
000019A0  103C 0002                507          MOVE.B  #2,D0           Input starting location (as string / hex)
000019A4  4E4F                     508          TRAP    #15
000019A6                           509  
000019A6  B23C 0008                510          CMP.B   #8,D1           Compare the length of the input to 8
000019AA  6EAA                     511          BGT     ILL1            Branch to ILL1 if > 8
000019AC  2011                     512          MOVE.L  (A1),D0         Move input to D0
000019AE  B23C 0000                513          CMP.B   #0,D1           Compare the length of the input to 0
000019B2  67B0                     514          BEQ     ILL2            If the input was null, branch to ILL2
000019B4  6100 FD24                515          BSR     ASCII2HEX       Else, convert D0 to HEX in D1
000019B8                           516          
000019B8  2281                     517          MOVE.L  D1,(A1)         Set SLOC to HEX value
000019BA  B2BC 0000F0FF            518          CMP.L   #$0000F0FF,D1   Compare starting location to 0
000019C0  6700 0AA2                519          BEQ     HALT            End program if 0
000019C4                           520          
000019C4  B2BC 00007000            521          CMP.L   #MNADDR,D1      Compare starting location to min
000019CA  6500 FF7C                522          BLO     ILL0            Branch to ILL0 if < min
000019CE                           523          
000019CE  B2BC 00FFFFFE            524          CMP.L   #MXADDR,D1      Compare ending location to max
000019D4  6480                     525          BHS     ILL1            Branch to ILL1 if >= max
000019D6                           526                  
000019D6  6000 0038                527          BRA     PRMPT2          Branch to the next prompt
000019DA                           528  
000019DA  43F8 15E9                529  ILL3    LEA     ERR0,A1         Ending location was too small
000019DE  103C 000E                530          MOVE.B  #14,D0
000019E2  4E4F                     531          TRAP    #15
000019E4  6000 002A                532          BRA     PRMPT2
000019E8                           533          
000019E8  43F8 1626                534  ILL4    LEA     ERR1,A1         Ending location was too big
000019EC  103C 000E                535          MOVE.B  #14,D0
000019F0  4E4F                     536          TRAP    #15
000019F2                           537  
000019F2  103C 000B                538  ILL5    MOVE.B  #11,D0          Position cursor at ROW/COL
000019F6  323C 1B17                539          MOVE.W  #$1B17,D1       Position after input location
000019FA  4E4F                     540          TRAP    #15
000019FC  203C 00FFFFFE            541          MOVE.L  #MXADDR,D0      Move max address to D0
00001A02  6100 FEBC                542          BSR     DSPHXL          Display max address to screen
00001A06  22BC 00FFFFFE            543          MOVE.L  #MXADDR,(A1)    Move the max address to ELOC
00001A0C  6000 006C                544          BRA     PRMPTDN         Branch to prompt done
00001A10                           545          
00001A10  123C 0015                546  PRMPT2  MOVE.B  #$15,D1         Set row to $15
00001A14  6100 FF12                547          BSR     CLRRW           Clear the row (if existing error is present)
00001A18  123C 0017                548          MOVE.B  #$17,D1         Set row to $17
00001A1C  6100 FF0A                549          BSR     CLRRW           Clear the row (if existing input is present)
00001A20  103C 000B                550          MOVE.B  #11,D0          Position cursor at COL/ROW
00001A24  323C 0016                551          MOVE.W  #$0016,D1       Position
00001A28  4E4F                     552          TRAP    #15
00001A2A                           553  
00001A2A  43F8 13B2                554          LEA     MSSG2,A1        Ending location request message
00001A2E  103C 000E                555          MOVE.B  #14,D0
00001A32  4E4F                     556          TRAP    #15
00001A34                           557          
00001A34  43F8 1054                558          LEA     ELOC,A1         Input will be stored in SLOC
00001A38  103C 0002                559          MOVE.B  #2,D0           Input starting location (as string / hex)
00001A3C  4E4F                     560          TRAP    #15
00001A3E                           561          
00001A3E  B23C 0008                562          CMP.B   #8,D1           Compare the length of the input to 8
00001A42  6EA4                     563          BGT     ILL4            Branch to ILL4 if > 8
00001A44  2011                     564          MOVE.L  (A1),D0         Move input to D0
00001A46  B23C 0000                565          CMP.B   #0,D1           Compare the length of the input to 0
00001A4A  67A6                     566          BEQ     ILL5            If the input was null, branch to ILL5
00001A4C  6100 FC8C                567          BSR     ASCII2HEX       Else, convert D0 to HEX in D1
00001A50                           568          
00001A50  2281                     569          MOVE.L  D1,(A1)         Set ELOC to HEX value
00001A52                           570  
00001A52  B2BC 0000F0FF            571          CMP.L   #$0000F0FF,D1   Compare ending location to 0
00001A58  6700 0A0A                572          BEQ     HALT            End program if 0
00001A5C                           573          
00001A5C  B2BC 00007000            574          CMP.L   #MNADDR,D1      Compare min ending location to min
00001A62  6300 FF76                575          BLS     ILL3            Branch to ILL3 if <= min
00001A66                           576          
00001A66  B2BC 00FFFFFE            577          CMP.L   #MXADDR,D1      Compare ending location to max
00001A6C  6200 FF7A                578          BHI     ILL4            Branch to ILL4 if > max
00001A70                           579          
00001A70  2038 1004                580          MOVE.L  (SLOC),D0       Move starting location data to D0
00001A74  B280                     581          CMP.L   D0,D1           Compare ending location to starting location
00001A76  6300 FF62                582          BLS     ILL3            Branch to ILL3 if <= starting location
00001A7A                           583          
00001A7A  123C 0018                584  PRMPTDN MOVE.B  #$18,D1         Set row to $18
00001A7E  6100 FEA8                585          BSR     CLRRW           Clear the row (if existing error is present)
00001A82  103C 000B                586          MOVE.B  #11,D0          Position cursor at COL/ROW
00001A86  323C 0019                587          MOVE.W  #$0019,D1       Position
00001A8A  4E4F                     588          TRAP    #15
00001A8C                           589  
00001A8C  43F8 141C                590          LEA     MSSG3,A1        Confirmation message
00001A90  103C 000E                591          MOVE.B  #14,D0
00001A94  4E4F                     592          TRAP    #15
00001A96  21F8 1004 1000           593          MOVE.L  (SLOC),(GBUFF)  Store starting location in GBUFF for OP
00001A9C  21F8 1004 10A4           594          MOVE.L  (SLOC),(NGBUFF) Copy to NGBUFF
00001AA2  6000 0932                595          BRA     REQKEY          Branch to request key
00001AA6                           596  
00001AA6                           597  *
00001AA6                           598  * Display An: Displays An or SP if n == 7
00001AA6                           599  * Input n in D3
00001AA6                           600  *
00001AA6                           601  
00001AA6  B63C 0007                602  DSPAn   CMP.B   #7,D3               Compare n to 7
00001AAA  6700 0016                603          BEQ     DSPSP               If ==, branch to Display SP
00001AAE  103C 0006                604          MOVE.B  #6,D0               Else, display character
00001AB2  123C 0041                605          MOVE.B  #'A',D1             Read A
00001AB6  4E4F                     606          TRAP    #15
00001AB8  4280                     607          CLR.L   D0
00001ABA  2003                     608          MOVE.L  D3,D0               Read reg from D3
00001ABC  6100 FDC8                609          BSR     DSPHXB              Display as hex byte
00001AC0  4E75                     610          RTS                         Return to caller
00001AC2                           611  
00001AC2  103C 0006                612  DSPSP   MOVE.B  #6,D0               Display character
00001AC6  123C 0053                613          MOVE.B  #'S',D1             Read S
00001ACA  4E4F                     614          TRAP    #15
00001ACC  123C 0050                615          MOVE.B  #'P',D1             Read P
00001AD0  4E4F                     616          TRAP    #15
00001AD2  4E75                     617          RTS                         Return to caller
00001AD4                           618  
00001AD4                           619  *
00001AD4                           620  * Brief Extension Word: Displays a brief extension word (without displacement)
00001AD4                           621  * Input BEW to D0.B
00001AD4                           622  * X|REG|S|SC|0 -> Xn.S * SC
00001AD4                           623  * X (Index Register Type):
00001AD4                           624  *   0 = Dn
00001AD4                           625  *   1 = An
00001AD4                           626  * S (Index Size):
00001AD4                           627  *   0 = Sign-Extended Word
00001AD4                           628  *   1 = Long Word
00001AD4                           629  * SC (Scale):
00001AD4                           630  *   00 = 1
00001AD4                           631  *   01 = 2
00001AD4                           632  *   10 = 4
00001AD4                           633  *   11 = 8
00001AD4                           634  *
00001AD4                           635  
00001AD4  48E7 F000                636  BEXTW   MOVEM.L D0-D3,-(SP)         Push D0-D3 to stack
00001AD8  7470                     637          MOVE.L  #$70,D2             Extract REG at 01110000
00001ADA  6100 FD62                638          BSR     EXTMSK              Get REG to D1
00001ADE  1601                     639          MOVE.B  D1,D3               Move REG to D3
00001AE0  243C 00000080            640          MOVE.L  #$80,D2             Extract X at 10000000
00001AE6  6100 FD56                641          BSR     EXTMSK              Get X to D1
00001AEA  1401                     642          MOVE.B  D1,D2               Move MODE to D2
00001AEC  6100 00E0                643          BSR     DISPOP              Display Xn
00001AF0  7408                     644          MOVE.L  #8,D2               Extract S at 00001000
00001AF2  6100 FD4A                645          BSR     EXTMSK              Get S to D1
00001AF6  1601                     646          MOVE.B  D1,D3               Move S to D3
00001AF8  7406                     647          MOVE.L  #6,D2               Extract SC at 00000110
00001AFA  6100 FD42                648          BSR     EXTMSK              Get SC to D1
00001AFE  C2FC 0004                649          MULU.W  #4,D1               Convert D1 to displacement
00001B02  4EFB 1002                650          JMP     SCTBL(PC,D1.W)      Jump to SC mode
00001B06  6000 000E                651  SCTBL   BRA     SC0                 00
00001B0A  6000 0012                652          BRA     SC1                 01
00001B0E  6000 0016                653          BRA     SC2                 10
00001B12  6000 001A                654          BRA     SC3                 11
00001B16  143C 0001                655  SC0     MOVE.B  #1,D2               00 = 1
00001B1A  6000 001A                656          BRA     SC4
00001B1E  143C 0002                657  SC1     MOVE.B  #2,D2               01 = 2
00001B22  6000 0012                658          BRA     SC4
00001B26  143C 0004                659  SC2     MOVE.B  #4,D2               10 = 4
00001B2A  6000 000A                660          BRA     SC4
00001B2E  143C 0008                661  SC3     MOVE.B  #8,D2               11 = 8
00001B32  6000 0002                662          BRA     SC4
00001B36  103C 0006                663  SC4     MOVE.B  #6,D0               Display character
00001B3A  123C 002E                664          MOVE.B  #'.',D1              Read . to D1
00001B3E  4E4F                     665          TRAP    #15
00001B40  123C 004C                666          MOVE.B  #'L',D1             Read L to D1 as default
00001B44  4A03                     667          TST.B   D3                  Test D3 for W
00001B46  6604                     668          BNE     *+6                 If !=, skip next line
00001B48  123C 0057                669          MOVE.B  #'W',D1             Else, read W to D1
00001B4C  4E4F                     670          TRAP    #15
00001B4E  123C 002A                671          MOVE.B  #'*',D1             Read *
00001B52  4E4F                     672          TRAP    #15
00001B54  103C 0003                673          MOVE.B  #3,D0               Display number
00001B58  1202                     674          MOVE.B  D2,D1               Read scale
00001B5A  4E4F                     675          TRAP    #15
00001B5C  4CDF 000F                676          MOVEM.L (SP)+,D0-D3         Restore D0-D3
00001B60  4E75                     677          RTS                         Return to caller
00001B62                           678  
00001B62                           679  * Display displacement in D1.L
00001B62  48E7 E000                680  DISPDIS MOVEM.L D0-D2,-(SP)         Push D0-D2 to stack
00001B66  5481                     681          ADD.L   #2,D1               Add 2 to displacement to account  for instruction
00001B68  2401                     682          MOVE.L  D1,D2               Copy displacement to D2
00001B6A  103C 0006                683          MOVE.B  #6,D0               Display character
00001B6E  123C 002A                684          MOVE.B  #'*',D1             Read *
00001B72  4E4F                     685          TRAP    #15
00001B74  B4BC 00000000            686          CMP.L   #0,D2               Compare data to 0
00001B7A  6F06                     687          BLE     *+8                 If < 0, skip next two lines
00001B7C  123C 002B                688          MOVE.B  #'+',D1             Else, read +
00001B80  4E4F                     689          TRAP    #15
00001B82  103C 0003                690          MOVE.B  #3,D0               Display signed number
00001B86  2202                     691          MOVE.L  D2,D1               Read data
00001B88  4E4F                     692          TRAP    #15
00001B8A  103C 0006                693          MOVE.B  #6,D0               Display character
00001B8E  123C 0020                694          MOVE.B  #' ',D1             Read space
00001B92  4E4F                     695          TRAP    #15
00001B94  123C 0028                696          MOVE.B  #'(',D1             Read (
00001B98  4E4F                     697          TRAP    #15
00001B9A  123C 0024                698          MOVE.B  #'$',D1             Read $
00001B9E  4E4F                     699          TRAP    #15
00001BA0  2038 1000                700          MOVE.L  (GBUFF),D0          Move GBUFF address to D0
00001BA4  D082                     701          ADD.L   D2,D0               Add displacement to address
00001BA6  B0BC 0000FFFF            702          CMP.L   #$FFFF,D0           Compare address to greatest word addres
00001BAC  6E04                     703          BGT.S   *+6                 If >, skip next line
00001BAE  6100 FCEA                704          BSR     DSPHXW              Else, display hex word
00001BB2  B0BC 0000FFFF            705          CMP.L   #$FFFF,D0           Compare again
00001BB8  6F04                     706          BLE.S   *+6                 If <=, skip next line
00001BBA  6100 FD04                707          BSR     DSPHXL              Else, display as hex long
00001BBE  103C 0006                708          MOVE.B  #6,D0               Display character
00001BC2  123C 0029                709          MOVE.B  #')',D1             Read )
00001BC6  4E4F                     710          TRAP    #15
00001BC8  4CDF 0007                711          MOVEM.L (SP)+,D0-D2         Restore D0-D2
00001BCC  4E75                     712          RTS                         Return to caller
00001BCE                           713  
00001BCE                           714  *
00001BCE                           715  * Display operand: Displays operand according to mode and register
00001BCE                           716  * Input mode in D2.B, input reg in D3.B
00001BCE                           717  *
00001BCE                           718  
00001BCE  48E7 FFFF                719  DISPOP  MOVEM.L D0-D7/A0-A7,-(SP)   Push all registers to stack
00001BD2  103C 0006                720          MOVE.B  #6,D0               Display character
00001BD6  C4FC 0004                721          MULU.W  #4,D2
00001BDA  4EFB 2002                722          JMP     DMDTBL(PC,D2.W)     Jump to mode
00001BDE  6000 0032                723  DMDTBL  BRA     DISPM0              Dn
00001BE2  6000 0040                724          BRA     DISPM1              An
00001BE6  6000 0044                725          BRA     DISPM2              (An)
00001BEA  6000 0058                726          BRA     DISPM3              (An)+
00001BEE  6000 0072                727          BRA     DISPM4              -(An)
00001BF2  6000 008C                728          BRA     DISPM5              (d,An)
00001BF6  6000 00BC                729          BRA     DISPM6              (d,An,Xn)
00001BFA  6000 0104                730          BRA     DISPM7              (XXX).W/(XXX).L/(d,PC)/(d,PC,Xn)/#data
00001BFE  6000 0224                731          BRA     DISPM8              Memory Snipers  CUSTOM
00001C02  6000 0456                732          BRA     DISPM9              Special (111) next word
00001C06  6000 0466                733          BRA     DISPMA              Memory Snipers CUSTOM (1000) next word
00001C0A  6000 0476                734          BRA     DISPMB              Memory Snipers CUSTOM (1000) previous word
00001C0E  6000 0486                735          BRA     DISPMC              Memory Snipers CUSTOM (1000) previous long
00001C12                           736  * Dn            0000 XXXX
00001C12  123C 0044                737  DISPM0  MOVE.B  #'D',D1             Read D
00001C16  4E4F                     738          TRAP    #15
00001C18  4280                     739          CLR.L   D0
00001C1A  1003                     740          MOVE.B  D3,D0               Read reg from D3
00001C1C  6100 FC68                741          BSR     DSPHXB              Display as hex byte
00001C20  6000 0488                742          BRA     DISPRT              Branch to return
00001C24                           743  * An            0001 XXXX
00001C24  6100 FE80                744  DISPM1  BSR     DSPAn               Display An or SP        
00001C28  6000 0480                745          BRA     DISPRT              Branch to return
00001C2C                           746  * (An)          0010 XXXX
00001C2C  123C 0028                747  DISPM2  MOVE.B  #'(',D1             Read (
00001C30  4E4F                     748          TRAP    #15
00001C32  6100 FE72                749          BSR     DSPAn               Display An or SP
00001C36  103C 0006                750          MOVE.B  #6,D0               Display character
00001C3A  123C 0029                751          MOVE.B  #')',D1             Read )
00001C3E  4E4F                     752          TRAP    #15
00001C40  6000 0468                753          BRA     DISPRT              Branch to return
00001C44                           754  * (An)+         0011 XXXX
00001C44  123C 0028                755  DISPM3  MOVE.B  #'(',D1             Read (
00001C48  4E4F                     756          TRAP    #15
00001C4A  6100 FE5A                757          BSR     DSPAn               Display An or SP
00001C4E  103C 0006                758          MOVE.B  #6,D0               Display character
00001C52  123C 0029                759          MOVE.B  #')',D1             Read )
00001C56  4E4F                     760          TRAP    #15
00001C58  123C 002B                761          MOVE.B  #'+',D1             Read +
00001C5C  4E4F                     762          TRAP    #15
00001C5E  6000 044A                763          BRA     DISPRT              Branch to return
00001C62                           764  * -(An)         0100 XXXX
00001C62  123C 002D                765  DISPM4  MOVE.B  #'-',D1             Read +
00001C66  4E4F                     766          TRAP    #15
00001C68  123C 0028                767          MOVE.B  #'(',D1             Read (
00001C6C  4E4F                     768          TRAP    #15
00001C6E  6100 FE36                769          BSR     DSPAn               Display An or SP
00001C72  103C 0006                770          MOVE.B  #6,D0               Display character
00001C76  123C 0029                771          MOVE.B  #')',D1             Read )
00001C7A  4E4F                     772          TRAP    #15
00001C7C  6000 042C                773          BRA     DISPRT              Branch to return
00001C80                           774  * (d16,An)      0101 XXXX
00001C80  123C 0028                775  DISPM5  MOVE.B  #'(',D1             Read (
00001C84  4E4F                     776          TRAP    #15
00001C86  103C 0003                777          MOVE.B  #3,D0               Display signed number
00001C8A  2278 10AC                778          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001C8E  3211                     779          MOVE.W  (A1),D1             Read word to D1
00001C90  48C1                     780          EXT.L   D1                  Extend word to long
00001C92  4E4F                     781          TRAP    #15
00001C94  54B8 10AC                782          ADD.L   #2,(IOADDR)         Advance IO address by word
00001C98  103C 0006                783          MOVE.B  #6,D0               Display character
00001C9C  123C 002C                784          MOVE.B  #',',D1             Read ,
00001CA0  4E4F                     785          TRAP    #15
00001CA2  6100 FE02                786          BSR     DSPAn               Display An or SP
00001CA6  103C 0006                787          MOVE.B  #6,D0               Display character
00001CAA  123C 0029                788          MOVE.B  #')',D1             Read )
00001CAE  4E4F                     789          TRAP    #15
00001CB0  6000 03F8                790          BRA     DISPRT              Branch to return
00001CB4                           791  * (d8,An,Xn)    0110 XXXX
00001CB4  123C 0028                792  DISPM6  MOVE.B  #'(',D1             Read (
00001CB8  4E4F                     793          TRAP    #15
00001CBA  103C 0003                794          MOVE.B  #3,D0               Display signed number
00001CBE  2278 10AC                795          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001CC2  11D9 11C5                796          MOVE.B  (A1)+,(DIS)         Store byte to displacement (DIS) and post-increment A1
00001CC6  1211                     797          MOVE.B  (A1),D1             Read next byte to D1 for the actual displacement
00001CC8  4881                     798          EXT.W   D1                  Extend byte to word
00001CCA  48C1                     799          EXT.L   D1                  Extend word to long
00001CCC  4E4F                     800          TRAP    #15
00001CCE  103C 0006                801          MOVE.B  #6,D0               Display character
00001CD2  123C 002C                802          MOVE.B  #',',D1             Read ,
00001CD6  4E4F                     803          TRAP    #15
00001CD8  6100 FDCC                804          BSR     DSPAn               Display An or SP
00001CDC  103C 0006                805          MOVE.B  #6,D0               Display character
00001CE0  123C 002C                806          MOVE.B  #',',D1             Read ,
00001CE4  4E4F                     807          TRAP    #15
00001CE6  1038 11C5                808          MOVE.B  (DIS),D0            Read (DIS) to D0
00001CEA  6100 FDE8                809          BSR     BEXTW               Display Brief Extension Word
00001CEE  54B8 10AC                810          ADD.L   #2,(IOADDR)         Advance IO address by word
00001CF2  103C 0006                811          MOVE.B  #6,D0               Display character
00001CF6  123C 0029                812          MOVE.B  #')',D1             Read )
00001CFA  4E4F                     813          TRAP    #15
00001CFC  6000 03AC                814          BRA     DISPRT              Branch to return
00001D00                           815  * (XXX).W/(XXX).L/(d16,PC)/(d8,PC,Xn)/#data
00001D00  C6FC 0004                816  DISPM7  MULU.W  #4,D3
00001D04  4EFB 3002                817          JMP     DRGTBL(PC,D3.W)     Jump to reg
00001D08  6000 0016                818  DRGTBL  BRA     DISPR0              (XXX).W
00001D0C  6000 002E                819          BRA     DISPR1              (XXX).L
00001D10  6000 0046                820          BRA     DISPR2              (d,PC)
00001D14  6000 007A                821          BRA     DISPR3              (d,PC,Xn)
00001D18  6000 00C6                822          BRA     DISPR4              #data
00001D1C  6000 00F4                823          BRA     DISPR5              CCR
00001D20                           824  * (XXX.W)       0111 0000
00001D20  123C 0024                825  DISPR0  MOVE.B  #'$',D1             Read $
00001D24  4E4F                     826          TRAP    #15
00001D26  2278 10AC                827          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001D2A  4282                     828          CLR.L   D2
00001D2C  143C 0002                829          MOVE.B  #2,D2               Read word size to D2
00001D30  6100 FB2E                830          BSR     DSPHXA              Display address
00001D34  D5B8 10AC                831          ADD.L   D2,(IOADDR)         Advance IO address by word
00001D38  6000 0370                832          BRA     DISPRT              Branch to return
00001D3C                           833  * (XXX.L)       0111 0001
00001D3C  123C 0024                834  DISPR1  MOVE.B  #'$',D1             Read $
00001D40  4E4F                     835          TRAP    #15
00001D42  2278 10AC                836          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001D46  4282                     837          CLR.L   D2
00001D48  143C 0004                838          MOVE.B  #4,D2               Read long size to D2
00001D4C  6100 FB12                839          BSR     DSPHXA              Display address
00001D50  D5B8 10AC                840          ADD.L   D2,(IOADDR)         Advance IO address by long
00001D54  6000 0354                841          BRA     DISPRT              Branch to return
00001D58                           842  * (d16,PC)      0111 0010
00001D58  123C 0028                843  DISPR2  MOVE.B  #'(',D1             Read (
00001D5C  4E4F                     844          TRAP    #15
00001D5E  103C 0003                845          MOVE.B  #3,D0               Display signed number
00001D62  2278 10AC                846          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001D66  3211                     847          MOVE.W  (A1),D1             Read word to D1
00001D68  48C1                     848          EXT.L   D1                  Extend word to long
00001D6A  4E4F                     849          TRAP    #15
00001D6C  54B8 10AC                850          ADD.L   #2,(IOADDR)         Advance IO address by word
00001D70  103C 0006                851          MOVE.B  #6,D0               Display character
00001D74  123C 002C                852          MOVE.B  #',',D1             Read ,
00001D78  4E4F                     853          TRAP    #15
00001D7A  123C 0050                854          MOVE.B  #'P',D1             Read P
00001D7E  4E4F                     855          TRAP    #15
00001D80  123C 0043                856          MOVE.B  #'C',D1             Read C
00001D84  4E4F                     857          TRAP    #15
00001D86  123C 0029                858          MOVE.B  #')',D1             Read )
00001D8A  4E4F                     859          TRAP    #15
00001D8C  6000 031C                860          BRA     DISPRT              
00001D90                           861  * (d8,PC,Xn)    0111 0011
00001D90  123C 0028                862  DISPR3  MOVE.B  #'(',D1             Read (
00001D94  4E4F                     863          TRAP    #15
00001D96  103C 0003                864          MOVE.B  #3,D0               Display signed number
00001D9A  2278 10AC                865          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001D9E  11D9 11C5                866          MOVE.B  (A1)+,(DIS)         Store byte to displacement (DIS) and post-increment A1
00001DA2  1211                     867          MOVE.B  (A1),D1             Read next byte to D1 for the actual displacement
00001DA4  4881                     868          EXT.W   D1                  Extend byte to word
00001DA6  48C1                     869          EXT.L   D1                  Extend word to long
00001DA8  4E4F                     870          TRAP    #15
00001DAA  103C 0006                871          MOVE.B  #6,D0               Display character
00001DAE  123C 002C                872          MOVE.B  #',',D1             Read ,
00001DB2  4E4F                     873          TRAP    #15
00001DB4  123C 0050                874          MOVE.B  #'P',D1             Read P
00001DB8  4E4F                     875          TRAP    #15
00001DBA  123C 0043                876          MOVE.B   #'C',D1            Read C
00001DBE  4E4F                     877          TRAP    #15
00001DC0  123C 002C                878          MOVE.B  #',',D1             Read ,
00001DC4  4E4F                     879          TRAP    #15
00001DC6  1038 11C5                880          MOVE.B  (DIS),D0            Read (DIS) to D0
00001DCA  6100 FD08                881          BSR     BEXTW               Display Brief Extension Word
00001DCE  54B8 10AC                882          ADD.L   #2,(IOADDR)         Advance IO address by word
00001DD2  103C 0006                883          MOVE.B  #6,D0               Display character
00001DD6  123C 0029                884          MOVE.B  #')',D1             Read )
00001DDA  4E4F                     885          TRAP    #15
00001DDC  6000 02CC                886          BRA     DISPRT              Branch to return
00001DE0                           887  * #<data>       0111 0100
00001DE0  123C 0023                888  DISPR4  MOVE.B  #'#',D1             Read #
00001DE4  4E4F                     889          TRAP    #15
00001DE6  123C 0024                890          MOVE.B  #'$',D1             Read $
00001DEA  4E4F                     891          TRAP    #15
00001DEC  2278 10AC                892          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001DF0  4282                     893          CLR.L   D2
00001DF2  1438 10AA                894          MOVE.B  (IOSIZE),D2         Read instruction size to D2
00001DF6  B43C 0000                895          CMP.B   #0,D2               Test if size is byte
00001DFA  6604                     896          BNE     *+6                 If !=, skip next line
00001DFC  143C 0001                897          MOVE.B  #1,D2               If ==, change byte to word
00001E00  C4FC 0002                898          MULU.W  #2,D2               Translate size to value
00001E04  6100 FA5A                899          BSR     DSPHXA              Display address
00001E08  D3C2                     900          ADD.L   D2,A1               Advance A1 by instruction size
00001E0A  21C9 10AC                901          MOVE.L  A1,(IOADDR)         Move A1 to IOADDR
00001E0E  6000 029A                902          BRA     DISPRT              Branch to return
00001E12                           903  * CCR
00001E12  123C 0043                904  DISPR5  MOVE.B  #'C',D1             Read C
00001E16  4E4F                     905          TRAP    #15
00001E18  4E4F                     906          TRAP    #15
00001E1A  123C 0052                907          MOVE.B  #'R',D1             Read R
00001E1E  4E4F                     908          TRAP    #15
00001E20  6000 0288                909          BRA     DISPRT              Branch to return
00001E24                           910  *  Memory Snipers CUSTOM MODE
00001E24                           911  * Custom sizes:
00001E24                           912  *   Q = Quick data
00001E24  C6FC 0004                913  DISPM8  MULU.W  #4,D3
00001E28  4EFB 3002                914          JMP     D3BTBL(PC,D3.W)     Jump to reg
00001E2C  6000 0026                915  D3BTBL  BRA     DISPC0              #<1-8>.Q
00001E30  6000 004C                916          BRA     DISPC1              #<data>.Q
00001E34  6000 0068                917          BRA     DISPC2              (DIS).Q
00001E38  6000 0084                918          BRA     DISPC3              (DIS).B
00001E3C  6000 0096                919          BRA     DISPC4              (DIS).W
00001E40  6000 00A6                920          BRA     DISPC5              (DIS).L
00001E44  6000 00B4                921          BRA     DISPC6              (RLM).L
00001E48  6000 013E                922          BRA     DISPC7              (MLR).L
00001E4C  6000 01D0                923          BRA     DISPC8              #<bit num>.B
00001E50  6000 01E4                924          BRA     DISPC9              #<0-7>.Q
00001E54                           925  
00001E54                           926  * #<1-8>.Q     1000 0000
00001E54  123C 0023                927  DISPC0  MOVE.B  #'#',D1             Read #
00001E58  4E4F                     928          TRAP    #15
00001E5A  4280                     929          CLR.L   D0
00001E5C  4281                     930          CLR.L   D1
00001E5E  2278 10AC                931          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001E62  3021                     932          MOVE.W  -(A1),D0            Pre-decrement location, get instruction to D0
00001E64  243C 00000E00            933          MOVE.L  #$0E00,D2           Extract data at 000011100000000
00001E6A  6100 F9D2                934          BSR     EXTMSK              Get the data to D1
00001E6E  4A41                     935          TST     D1                  Compare data to 0
00001E70  6602                     936          BNE     *+4                 If !=, skip the next line
00001E72  7208                     937          MOVE.L  #8,D1               Else, change 0 to 8
00001E74  103C 0003                938          MOVE.B  #3,D0               Read number
00001E78  4E4F                     939          TRAP    #15
00001E7A  6000 022E                940          BRA     DISPRT              Branch to return
00001E7E                           941  * #<data>.Q     1000 0001
00001E7E  123C 0023                942  DISPC1  MOVE.B  #'#',D1             Read #
00001E82  4E4F                     943          TRAP    #15
00001E84  4280                     944          CLR.L   D0
00001E86  4281                     945          CLR.L   D1
00001E88  2278 10AC                946          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001E8C  3021                     947          MOVE.W  -(A1),D0            Pre-decrement location, get instruction to D0
00001E8E  740F                     948          MOVE.L  #$000F,D2           Extract data at 0000000000001111
00001E90  6100 F9AC                949          BSR     EXTMSK              Get the data to D1
00001E94  103C 0003                950          MOVE.B  #3,D0               Read number
00001E98  4E4F                     951          TRAP    #15
00001E9A  6000 020E                952          BRA     DISPRT              Branch to return
00001E9E                           953  * (DIS).Q       1000 0010
00001E9E                           954  * "1000 BRA -7 *Branch back 7 bytes
00001E9E                           955  *  is acceptable, but:
00001E9E                           956  *  1000 BRA 993 * Branch to address 993
00001E9E                           957  *  is better."
00001E9E                           958  *   Memory Snipers believes:
00001E9E                           959  *  1000 BRA *-7 ($993)
00001E9E                           960  *  is BEST.
00001E9E  4280                     961  DISPC2  CLR.L   D0
00001EA0  4281                     962          CLR.L   D1
00001EA2  2278 10AC                963          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001EA6  3021                     964          MOVE.W  -(A1),D0            Pre-decrement location, get instruction to D0
00001EA8  243C 000000FF            965          MOVE.L  #$00FF,D2           Extract byte displacement at 0000000011111111
00001EAE  6100 F98E                966          BSR     EXTMSK              Get the data to D1
00001EB2  4881                     967          EXT.W   D1                  Extend byte to word
00001EB4  48C1                     968          EXT.L   D1                  Extend word to long
00001EB6  6100 FCAA                969          BSR     DISPDIS             Display displacement
00001EBA  6000 01EE                970          BRA     DISPRT              Branch to return
00001EBE                           971          
00001EBE                           972  * (DIS).B       1000 0011
00001EBE  4280                     973  DISPC3  CLR.L   D0
00001EC0  4281                     974          CLR.L   D1
00001EC2  2278 10AC                975          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001EC6  3211                     976          MOVE.W  (A1),D1             Get displacement to D1
00001EC8  4881                     977          EXT.W   D1                  Extend byte to word
00001ECA  48C1                     978          EXT.L   D1                  Extend word to long
00001ECC  6100 FC94                979          BSR     DISPDIS             Display displacement
00001ED0  6000 01D8                980          BRA     DISPRT              Branch to return
00001ED4                           981  * (DIS).W       1000 0100
00001ED4  4280                     982  DISPC4  CLR.L   D0
00001ED6  4281                     983          CLR.L   D1
00001ED8  2278 10AC                984          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001EDC  3211                     985          MOVE.W  (A1),D1             Get displacement to D1
00001EDE  48C1                     986          EXT.L   D1                  Extend word to long
00001EE0  6100 FC80                987          BSR     DISPDIS             Display displacement
00001EE4  6000 01C4                988          BRA     DISPRT              Branch to return
00001EE8                           989  * (DIS).L       1000 0101
00001EE8  4280                     990  DISPC5  CLR.L   D0
00001EEA  4281                     991          CLR.L   D1
00001EEC  2278 10AC                992          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00001EF0  2211                     993          MOVE.L  (A1),D1             Get displacement to D1
00001EF2  6100 FC6E                994          BSR     DISPDIS             Display displacement
00001EF6  6000 01B2                995          BRA     DISPRT              Branch to return
00001EFA                           996  * (RLM).W       1000 0110
00001EFA  2278 10AC                997  DISPC6  MOVEA.L IOADDR,A1   Point A1 to the instruction address
00001EFE  4282                     998          CLR.L   D2
00001F00  3411                     999          MOVE.W  (A1),D2     Get register list mask to D2
00001F02  7600                    1000          MOVE.L  #0,D3       Count
00001F04  1A3C 0044               1001          MOVE.B  #'D',D5     D/A
00001F08  1C3C 0000               1002          MOVE.B  #$00,D6     / or - separator (set to null for first 1)
00001F0C  207C 00001F78           1003          MOVE.L  #RLMNXT,A0  Next instruction
00001F12  0702                    1004  RLMLP   BTST.L  D3,D2       Check bit at count for 0
00001F14  6700 0058               1005          BEQ     RLMADV      If bit was 0, branch to LPADV
00001F18  103C 0006               1006          MOVE.B  #6,D0       Else, display character
00001F1C  1206                    1007          MOVE.B  D6,D1       Read separator
00001F1E  1C3C 002F               1008          MOVE.B  #'/',D6     Set next default separator to /
00001F22  4E4F                    1009          TRAP    #15
00001F24  1205                    1010          MOVE.B  D5,D1       Read A/D
00001F26  4E4F                    1011          TRAP    #15
00001F28  103C 0003               1012          MOVE.B  #3,D0       Display number
00001F2C  1203                    1013          MOVE.B  D3,D1       Read count
00001F2E  4E4F                    1014          TRAP    #15
00001F30  2803                    1015          MOVE.L  D3,D4       Move bit location to D4
00001F32  B63C 0007               1016  RLMINC  CMP.B   #7,D3       Compare count to 7
00001F36  6708                    1017          BEQ     *+10        If ==, branch to decrement count
00001F38  5203                    1018          ADD.B   #1,D3       Else, increment count
00001F3A  0702                    1019          BTST.L  D3,D2       Check next bit at count for 0
00001F3C  66F4                    1020          BNE     RLMINC      If bit was not 0, keep incrementing
00001F3E  5303                    1021          SUB.B   #1,D3       Decrement count
00001F40  4404                    1022          NEG.B   D4          Negate bit location
00001F42  D803                    1023          ADD.B   D3,D4       Add count to location; effectively, count - location = length
00001F44  B83C 0001               1024          CMP.B   #1,D4       Compare length to 1
00001F48  6F04                    1025          BLE     *+6         If <=, skip the next line
00001F4A  1C3C 002D               1026          MOVE.B  #'-',D6     Else, set separator to -
00001F4E  B83C 0000               1027          CMP.B   #0,D4       Compare length to 0
00001F52  6700 001A               1028          BEQ     RLMADV      If ==, branch to instruction
00001F56  103C 0006               1029          MOVE.B  #6,D0       Else, display character
00001F5A  1206                    1030          MOVE.B  D6,D1       Read separator
00001F5C  1C3C 002F               1031          MOVE.B  #'/',D6     Set next default separator to /
00001F60  4E4F                    1032          TRAP    #15
00001F62  1205                    1033          MOVE.B  D5,D1       Read A/D
00001F64  4E4F                    1034          TRAP    #15
00001F66  103C 0003               1035          MOVE.B  #3,D0       Display number
00001F6A  1203                    1036          MOVE.B  D3,D1       Read count
00001F6C  4E4F                    1037          TRAP    #15
00001F6E  5203                    1038  RLMADV  ADD.B   #1,D3       Increment count
00001F70  B63C 0007               1039          CMP.B   #7,D3       Compare count to 7
00001F74  6F9C                    1040          BLE     RLMLP       If <=, branch back to loop
00001F76  4ED0                    1041          JMP     (A0)        Else, jump to address in A0
00001F78  E15A                    1042  RLMNXT  ROL.W   #8,D2       Move A bits to LSB
00001F7A  7600                    1043          MOVE.L  #0,D3       Count
00001F7C  1A3C 0041               1044          MOVE.B  #'A',D5     D/A
00001F80  207C 000020AA           1045          MOVE.L  #DISPRT,A0  Next instruction
00001F86  608A                    1046          BRA     RLMLP       Display A registers
00001F88                          1047  * (MLR).W       1000 0110
00001F88  2278 10AC               1048  DISPC7  MOVEA.L IOADDR,A1   Point A1 to the instruction address
00001F8C  4282                    1049          CLR.L   D2
00001F8E  3411                    1050          MOVE.W  (A1),D2     Get register list mask to D2
00001F90  E15A                    1051          ROL.W   #8,D2       Move D bits to LSB
00001F92  7607                    1052          MOVE.L  #7,D3       Count
00001F94  1A3C 0044               1053          MOVE.B  #'D',D5     D/A
00001F98  1C3C 0000               1054          MOVE.B  #$00,D6     / or - separator (set to null for first 1)
00001F9C  207C 0000200E           1055          MOVE.L  #MLRNXT,A0  Next instruction
00001FA2  0702                    1056  MLRLP   BTST.L  D3,D2       Check bit at count for 0
00001FA4  6700 005E               1057          BEQ     MLRADV      If bit was 0, branch to LPADV
00001FA8  103C 0006               1058          MOVE.B  #6,D0       Else, display character
00001FAC  1206                    1059          MOVE.B  D6,D1       Read separator
00001FAE  1C3C 002F               1060          MOVE.B  #'/',D6     Set next default separator to /
00001FB2  4E4F                    1061          TRAP    #15
00001FB4  1205                    1062          MOVE.B  D5,D1       Read A/D
00001FB6  4E4F                    1063          TRAP    #15
00001FB8  103C 0003               1064          MOVE.B  #3,D0       Display number
00001FBC  123C 0007               1065          MOVE.B  #7,D1       Read 7
00001FC0  9203                    1066          SUB.B   D3,D1       Subtract count
00001FC2  4E4F                    1067          TRAP    #15
00001FC4  2803                    1068          MOVE.L  D3,D4       Move bit location to D4
00001FC6  B63C 0000               1069  MLRDEC  CMP.B   #0,D3       Compare count to 0
00001FCA  6708                    1070          BEQ     *+10        If ==, branch to decrement count
00001FCC  5303                    1071          SUB.B   #1,D3       Else, decrement count
00001FCE  0702                    1072          BTST.L  D3,D2       Check next bit at count for 0
00001FD0  66F4                    1073          BNE     MLRDEC      If bit was not 0, keep decrementing
00001FD2  5203                    1074          ADD.B   #1,D3       Increment count
00001FD4  9803                    1075          SUB.B   D3,D4       Location - count = length
00001FD6  B83C 0001               1076          CMP.B   #1,D4       Compare length to 1
00001FDA  6F04                    1077          BLE     *+6         If <=, skip the next line
00001FDC  1C3C 002D               1078          MOVE.B  #'-',D6     Else, set separator to -
00001FE0  B83C 0000               1079          CMP.B   #0,D4       Compare length to 0
00001FE4  6700 001E               1080          BEQ     MLRADV      If ==, branch to instruction
00001FE8  103C 0006               1081          MOVE.B  #6,D0       Else, display character
00001FEC  1206                    1082          MOVE.B  D6,D1       Read separator
00001FEE  1C3C 002F               1083          MOVE.B  #'/',D6     Set next default separator to /
00001FF2  4E4F                    1084          TRAP    #15
00001FF4  1205                    1085          MOVE.B  D5,D1       Read A/D
00001FF6  4E4F                    1086          TRAP    #15
00001FF8  103C 0003               1087          MOVE.B  #3,D0       Display number
00001FFC  123C 0007               1088          MOVE.B  #7,D1       Read 7
00002000  9203                    1089          SUB.B   D3,D1       Subtract count
00002002  4E4F                    1090          TRAP    #15
00002004  5303                    1091  MLRADV  SUB.B   #1,D3       Decrement count
00002006  B63C 0000               1092          CMP.B   #0,D3       Compare count to 0
0000200A  6C96                    1093          BGE     MLRLP       If >=, branch back to loop
0000200C  4ED0                    1094          JMP     (A0)        Else, jump to address in A0
0000200E  E15A                    1095  MLRNXT  ROL.W   #8,D2       Move A bits to LSB
00002010  7607                    1096          MOVE.L  #7,D3       Count
00002012  1A3C 0041               1097          MOVE.B  #'A',D5     D/A
00002016  207C 000020AA           1098          MOVE.L  #DISPRT,A0  Next instruction
0000201C  6084                    1099          BRA     MLRLP       Display A registers
0000201E                          1100  * #<bit num>.B  1000 0111
0000201E  123C 0023               1101  DISPC8  MOVE.B  #'#',D1             Read #
00002022  4E4F                    1102          TRAP    #15
00002024  4281                    1103          CLR.L   D1
00002026  2278 10AC               1104          MOVEA.L IOADDR,A1           Point A1 to the instruction address
0000202A  3211                    1105          MOVE.W  (A1),D1             Read bit number to D1
0000202C  103C 0003               1106          MOVE.B  #3,D0               Display number
00002030  4E4F                    1107          TRAP    #15
00002032  6000 0076               1108          BRA     DISPRT              Branch to return
00002036                          1109  * #<0-7>.Q      1000 1000
00002036  123C 0023               1110  DISPC9  MOVE.B  #'#',D1             Read #
0000203A  4E4F                    1111          TRAP    #15
0000203C  4280                    1112          CLR.L   D0
0000203E  4281                    1113          CLR.L   D1
00002040  2278 10AC               1114          MOVEA.L IOADDR,A1           Point A1 to the instruction address
00002044  3021                    1115          MOVE.W  -(A1),D0            Pre-decrement location, get instruction to D0
00002046  243C 00000E00           1116          MOVE.L  #$0E00,D2           Extract data at 000011100000000
0000204C  6100 F7F0               1117          BSR     EXTMSK              Get the data to D1
00002050  103C 0003               1118          MOVE.B  #3,D0               Read number
00002054  4E4F                    1119          TRAP    #15
00002056  6000 0052               1120          BRA     DISPRT              Branch to return
0000205A                          1121  * Special-- next word: The mode was 111, but the value is located in the next word
0000205A  54B8 10AC               1122  DISPM9  ADD.L   #2,IOADDR           Advance IOADDR by word
0000205E  143C 0007               1123          MOVE.B  #%111,D2            Set mode to 111
00002062  6100 FB6A               1124          BSR     DISPOP              Display the special mode
00002066  55B8 10AC               1125          SUB.L   #2,IOADDR           Re-align IOADDR
0000206A  6000 003E               1126          BRA     DISPRT              Branch to return
0000206E                          1127  * 3B Special-- next word: The mode was 1000, but the value is located in the next word
0000206E  54B8 10AC               1128  DISPMA  ADD.L   #2,IOADDR           Increment IOADDR by word
00002072  143C 0008               1129          MOVE.B  #%1000,D2           Set mode to 1000
00002076  6100 FB56               1130          BSR     DISPOP              Display the special mode
0000207A  55B8 10AC               1131          SUB.L   #2,IOADDR           Re-align IOADDR
0000207E  6000 002A               1132          BRA     DISPRT              Branch to return
00002082                          1133  * 3B Special-- previous word: The mode was 1000, but the value is located in the previous word
00002082  55B8 10AC               1134  DISPMB  SUB.L   #2,IOADDR           Decrement IOADDR by word
00002086  143C 0008               1135          MOVE.B  #%1000,D2           Set mode to 1000
0000208A  6100 FB42               1136          BSR     DISPOP              Display the special mode
0000208E  54B8 10AC               1137          ADD.L   #2,IOADDR           Re-align IOADDR
00002092  6000 0016               1138          BRA     DISPRT              Branch to return
00002096                          1139  * 3B Special-- previous long: The mode was 1000, but the value is located in the previous long
00002096  59B8 10AC               1140  DISPMC  SUB.L   #4,IOADDR           Decrement IOADDR by long
0000209A  143C 0008               1141          MOVE.B  #%1000,D2           Set mode to 1000
0000209E  6100 FB2E               1142          BSR     DISPOP              Display the special mode
000020A2  54B8 10AC               1143          ADD.L   #2,IOADDR           Re-align IOADDR
000020A6  6000 0002               1144          BRA     DISPRT              Branch to return
000020AA                          1145          
000020AA  4CDF FFFF               1146  DISPRT  MOVEM.L (SP)+,D0-D7/A0-A7   Restore all registers
000020AE  4E75                    1147          RTS                         Return to caller
000020B0                          1148          
000020B0                          1149  
000020B0                          1150  * Display instruction: PRINT sub-routine
000020B0  43F8 10B2               1151  DISPINS LEA     OPNAME,A1           Read OP-code
000020B4  4280                    1152          CLR.L   D0                  Clear D0 for offset
000020B6  1038 10A8               1153          MOVE.B  (IOOPCD),D0         Get offset
000020BA  D3C0                    1154          ADD.L   D0,A1               Add offset
000020BC  6100 F80C               1155          BSR     DSPSTR              Display string until NULL char and get length in D1.B
000020C0  D401                    1156          ADD.B   D1,D2               Add length to space offset
000020C2  4E75                    1157          RTS                         Return to PRINT
000020C4                          1158  
000020C4                          1159  * Display size: PRINT sub-routine
000020C4  43F8 11B4               1160  DISPSZ  LEA     IOOPSZ,A1           Read OP code size
000020C8  103C 0003               1161          MOVE.B  #$03,D0             Set size to 3
000020CC  0C38 00FF 10AA          1162          CMP.B   #$FF,(IOSIZE)       Test if OP size exists
000020D2  6704                    1163          BEQ     *+6                 If OP size doesn't exist, skip the next line
000020D4  1038 10AA               1164          MOVE.B  (IOSIZE),D0         If OP size exists, move it to D0
000020D8  C0FC 0003               1165          MULU.W  #$3,D0              Multiply size by 3 for correct offset
000020DC  D3C0                    1166          ADD.L   D0,A1               Add offset
000020DE  6100 F7EA               1167          BSR     DSPSTR              Display string until NULL char and get length in D1.B
000020E2  D401                    1168          ADD.B   D1,D2               Add length to space offset
000020E4  4E75                    1169          RTS                         Return to PRINT
000020E6                          1170  
000020E6                          1171  * Display source: PRINT sub-routine
000020E6  4242                    1172  DISPSRC CLR.W   D2                  Clear mode offset so value <= 7
000020E8  4243                    1173          CLR.W   D3                  Clear reg offset so value <= 7
000020EA  1438 11C2               1174          MOVE.B  (SMD),D2            Read source mode to D2
000020EE  B43C 00FF               1175          CMP.B   #$FF,D2             Test if it exists
000020F2  6700 F5E0               1176          BEQ     FLAGCL              If it does not exist, branch to clear flag
000020F6  1638 11C3               1177          MOVE.B  (SRG),D3            Else, read source reg to D3
000020FA  B63C 00FF               1178          CMP.B   #$FF,D3             Test if it exists
000020FE  6700 F5D4               1179          BEQ     FLAGCL              If it does not exist, branch to clear flag
00002102  6000 F5CA               1180          BRA     FLAGST              Else, branch to set flag
00002106                          1181  
00002106                          1182  * Display destination: PRINT sub-routine
00002106  4242                    1183  DISPDST CLR.W   D2                  Reset mode offset
00002108  4243                    1184          CLR.W   D3                  Reset register offset
0000210A  1438 11C0               1185          MOVE.B  (DMD),D2            Read dest mode to D2
0000210E  B43C 00FF               1186          CMP.B   #$FF,D2             Test if it exists
00002112  6700 F5C0               1187          BEQ     FLAGCL              If it does not exist, branch to clear flag
00002116  1638 11C1               1188          MOVE.B  (DRG),D3            Else, read dest reg to D3
0000211A  B63C 00FF               1189          CMP.B   #$FF,D3             Test if it exists
0000211E  6700 F5B4               1190          BEQ     FLAGCL              If it does not exist, branch to clear flg
00002122  6000 F5AA               1191          BRA     FLAGST              Else, branch to set flag
00002126                          1192  
00002126                          1193  * Display address: PRINT sub-routine
00002126  103C 0006               1194  DISPADR MOVE.B  #6,D0               Display character
0000212A  123C 007C               1195          MOVE.B  #'|',D1             Read divider
0000212E  4E4F                    1196          TRAP    #15
00002130  123C 0020               1197          MOVE.B  #' ',D1             Read space
00002134  4E4F                    1198          TRAP    #15
00002136  2038 10AC               1199          MOVE.L  (IOADDR),D0         Read memory location
0000213A  6100 F784               1200          BSR     DSPHXL              Display as hex long
0000213E  103C 0006               1201          MOVE.B  #6,D0               Display character
00002142  123C 0020               1202          MOVE.B  #' ',D1             Read space
00002146  4E4F                    1203          TRAP    #15
00002148  123C 007C               1204          MOVE.B  #'|',D1             Read divider
0000214C  4E4F                    1205          TRAP    #15
0000214E  123C 0020               1206          MOVE.B  #' ',D1             Read space
00002152  4E4F                    1207          TRAP    #15
00002154  4E75                    1208          RTS                         Return to PRINT
00002156                          1209  
00002156                          1210  * Display raw data: PRINT sub-routine
00002156  48E7 2040               1211  DISPRAW MOVEM.L D2/A1,-(SP)
0000215A  2438 1000               1212          MOVE.L  (GBUFF),D2          Move GBUFF to D1
0000215E  94B8 10AC               1213          SUB.L   (IOADDR),D2         Subtract IOADDR from GBUFF
00002162  5482                    1214          ADD.L   #2,D2               Add word length
00002164  2278 10AC               1215          MOVEA.L IOADDR,A1           Point A1 to IOADDR
00002168  6100 F6F6               1216          BSR     DSPHXA              Display address with D1 length
0000216C  C4FC 0002               1217          MULU.W  #2,D2               Multiply length * 2 for offset space
00002170  4442                    1218          NEG.W   D2                  Negate D2
00002172  0642 0015               1219          ADD.W   #21,D2              Add 21; effectively, 21 - length
00002176  6100 F78C               1220          BSR     DSPOFS              Display offset space
0000217A  103C 0006               1221          MOVE.B  #6,D0               Display character
0000217E  123C 007C               1222          MOVE.B  #'|',D1             Read divider
00002182  4E4F                    1223          TRAP    #15
00002184  123C 0020               1224          MOVE.B  #' ',D1             Read space
00002188  4E4F                    1225          TRAP    #15
0000218A  4CDF 0204               1226          MOVEM.L (SP)+,D2/A1
0000218E  4E75                    1227          RTS                         Return to PRINT
00002190                          1228  
00002190                          1229  * Display bad code: PRINT sub-routine
00002190  103C 0006               1230  DISPBD  MOVE.B  #6,D0               Display character
00002194  123C 0020               1231          MOVE.B  #' ',D1             Read space
00002198  4E4F                    1232          TRAP    #15
0000219A  123C 0028               1233          MOVE.B  #'(',D1             Read (
0000219E  4E4F                    1234          TRAP    #15
000021A0  43F8 10B2               1235          LEA     OPNAME,A1           Read OP-code
000021A4  4280                    1236          CLR.L   D0                  Clear offset
000021A6  1038 10A9               1237          MOVE.B  (IOBDCD),D0         Get offset
000021AA  D3C0                    1238          ADD.L   D0,A1               Add offset
000021AC  6100 F71C               1239          BSR     DSPSTR              Display string until NULL char and get length in D1.B
000021B0  D401                    1240          ADD.B   D1,D2               Add length to space offset
000021B2  103C 0006               1241          MOVE.B  #6,D0               Display character
000021B6  123C 003F               1242          MOVE.B  #'?',D1
000021BA  4E4F                    1243          TRAP    #15                 Read ?
000021BC  123C 0029               1244          MOVE.B  #')',D1             Read )
000021C0  4E4F                    1245          TRAP    #15
000021C2  5802                    1246          ADD.B   #4,D2               Add 4 to space offset to account for (, ), ?, and space
000021C4  11FC 00FF 10A9          1247          MOVE.B  #$FF,(IOBDCD)       Reset BAD OPCODE
000021CA  4E75                    1248          RTS                         Return to PRINT
000021CC                          1249  
000021CC                          1250  * New Line: Displays a new line
000021CC  48A7 C000               1251  NEWLINE MOVEM.W D0/D1,-(SP)         Push D0 and D1 to stack
000021D0  103C 0006               1252          MOVE.B  #6,D0               Display character
000021D4  123C 000D               1253          MOVE.B  #CR,D1              Read carriage return
000021D8  4E4F                    1254          TRAP    #15
000021DA  123C 000A               1255          MOVE.B  #LF,D1              Read line feed
000021DE  4E4F                    1256          TRAP    #15
000021E0  4C9F 0003               1257          MOVEM.W (SP)+,D0/D1         Restore D0 and D1
000021E4  4E75                    1258          RTS                         Return to caller
000021E6                          1259  
000021E6                          1260  * Test Bad: Tests if BAD OPCODE exists, and is not BAD
000021E6                          1261  * Prevents screen from displaying DATA (DATA?) when NO instruction matched
000021E6  0C38 00FF 10A9          1262  TSTBAD  CMP.B   #$FF,IOBDCD         Check if BAD OPCODE exists
000021EC  6700 F4E6               1263          BEQ     FLAGCL              If it does not exists, branch to clear flag
000021F0  0C38 0087 10A9          1264          CMP.B   #$87,IOBDCD         Else, check if BAD OPCODE is bad
000021F6  6700 F4DC               1265          BEQ     FLAGCL              If ==, branch to clear flag
000021FA  6000 F4D2               1266          BRA     FLAGST              Else, branch to set flag
000021FE                          1267  
000021FE                          1268  * Bad: Where naughty instructions are sent to be punished
000021FE  11F8 10A8 10A9          1269  BRBAD   MOVE.B  (IOOPCD),(IOBDCD)   Move OPCODE to BAD OPCODE
00002204  11FC 0087 10A8          1270          MOVE.B  #$87,(IOOPCD)       Set OPCODE to BAD
0000220A  0C38 0004 10B1          1271          CMP.B   #4,IOBC             Compare bad counter to 4
00002210  6D00 0006               1272          BLT     BADADV              If < 4, branch to advance bad counter
00002214  4238 10B1               1273          CLR.B   (IOBC)              Else, set counter to 0
00002218  5238 10B1               1274  BADADV  ADD.B   #1,IOBC             Increment bad counter
0000221C                          1275          * Clear bad data
0000221C  11FC 00FF 11C2          1276          MOVE.B  #$FF,(SMD)
00002222  11FC 00FF 11C3          1277          MOVE.B  #$FF,(SRG)
00002228  11FC 00FF 11C0          1278          MOVE.B  #$FF,(DMD)
0000222E  11FC 00FF 11C1          1279          MOVE.B  #$FF,(DRG)
00002234  11FC 00FF 10AA          1280          MOVE.B  #$FF,(IOSIZE)
0000223A  6000 0002               1281          BRA     PRINT               Branch to PRINT
0000223E                          1282  
0000223E                          1283  * PRINT: WHERE ALL OF THE MAGIC HAPPENS!!! :D
0000223E  0C38 00FF 10A8          1284  PRINT   CMP.B   #$FF,(IOOPCD)       Test if OP code exists
00002244  67B8                    1285          BEQ     BRBAD               If it does not, display BAD
00002246                          1286  
00002246  4282                    1287          CLR.L   D2                  Clear D2 for space offset
00002248  4284                    1288          CLR.L   D4                  Set source to false
0000224A                          1289  
0000224A  0C38 0087 10A8          1290          CMP.B   #$87,(IOOPCD)       Compare OP code to BAD
00002250  6600 0090               1291          BNE     NOTBAD              If !=, branch to NOTBAD
00002254  0C38 0001 10B1          1292          CMP.B   #1,IOBC             Else, compare bad counter to 1
0000225A  6E00 0040               1293          BGT     DISPDAT             If > 1, branch to display raw data
0000225E  11FC 0001 10B1          1294  NEWBAD  MOVE.B  #1,(IOBC)           Set bad counter to 1
00002264  6100 FF66               1295          BSR     NEWLINE             Else, display new line
00002268  6100 FEBC               1296          BSR     DISPADR             Display address
0000226C  6100 FEE8               1297          BSR     DISPRAW             Display raw data
00002270  6100 FE3E               1298          BSR     DISPINS             Display instruction (DATA)
00002274  6100 FF70               1299          BSR     TSTBAD              Test if BAD OP code exists
00002278  6604                    1300          BNE     *+6                 If it doesn't exist, skip the next line
0000227A  6100 FF14               1301          BSR     DISPBD              Else, branch to DISPBD and reset IOBDCD
0000227E  4442                    1302          NEG.W   D2                  Negate space offset
00002280  0642 000E               1303          ADD.W   #14,D2              Add 13 to space offset; effectively 13 - space offset
00002284  6100 F67E               1304          BSR     DSPOFS              Display space offset with tab
00002288  103C 0006               1305          MOVE.B  #6,D0               Display character
0000228C  123C 007C               1306          MOVE.B  #'|',D1             Read divider
00002290  4E4F                    1307          TRAP    #15
00002292  123C 0020               1308          MOVE.B  #' ',D1             Read space
00002296  4E4F                    1309          TRAP    #15
00002298  5238 10B0               1310          ADD.B   #1,IOLC             Increment line counter to counteract DISPDAT
0000229C  6100 FF48               1311  DISPDAT BSR     TSTBAD              Test if BAD OP code exists
000022A0  67BC                    1312          BEQ     NEWBAD              If it exists, branch to NEWBAD to start a new line
000022A2  2278 10AC               1313          MOVE.L  IOADDR,A1           Else, point A1 to IOADDR
000022A6  343C 0002               1314          MOVE.W  #2,D2               Set size to word
000022AA  103C 000B               1315          MOVE.B  #11,D0              Position cursor COL/ROW
000022AE  1238 10B1               1316          MOVE.B  (IOBC),D1           Move bad counter to D1
000022B2  5301                    1317          SUB.B   #1,D1               Decrement by 1
000022B4  C2FC 0004               1318          MULU.W  #4,D1               Multiply by word space
000022B8  E149                    1319          LSL.W   #8,D1               Move to MSB
000022BA  0641 0D00               1320          ADD.W   #$0D00,D1           Add code column offset
000022BE  1238 10B0               1321          MOVE.B  IOLC,D1             Set row to line counter
000022C2  4E4F                    1322          TRAP    #15
000022C4  6100 F59A               1323          BSR     DSPHXA              Display hex word
000022C8  0641 2600               1324          ADD.W   #$2600,D1           Add operand column offset
000022CC  E159                    1325          ROL.W   #8,D1               Swap col and row
000022CE  D238 10B1               1326          ADD.B   (IOBC),D1           Add counter offset
000022D2  E159                    1327          ROL.W   #8,D1               Swap col and row
000022D4  4E4F                    1328          TRAP    #15
000022D6  6100 F588               1329          BSR     DSPHXA              Display hex word
000022DA  5338 10B0               1330          SUB.B   #1,IOLC             Decrement line counter
000022DE  6000 0066               1331          BRA     PRNTFIN             Branch to PRINT finish
000022E2  11FC 0000 10B1          1332  NOTBAD  MOVE.B  #0,(IOBC)           Reset bad counter
000022E8  6100 FEE2               1333          BSR     NEWLINE             Display new line
000022EC  6100 FE38               1334          BSR     DISPADR             Display address
000022F0  6100 FE64               1335          BSR     DISPRAW             Display raw data
000022F4  6100 FDBA               1336          BSR     DISPINS             Display instruction
000022F8  6100 FDCA               1337          BSR     DISPSZ              Display size
000022FC  4442                    1338          NEG.W   D2                  Negate space offset
000022FE  0642 000E               1339          ADD.W   #14,D2              Add 14 to space offset; effectively 14 - space offset
00002302  6100 F600               1340          BSR     DSPOFS              Display space offset with tab
00002306  103C 0006               1341          MOVE.B  #6,D0               Display character
0000230A  123C 007C               1342          MOVE.B  #'|',D1             Read divider
0000230E  4E4F                    1343          TRAP    #15
00002310  123C 0020               1344          MOVE.B  #' ',D1             Read space
00002314  4E4F                    1345          TRAP    #15
00002316  54B8 10AC               1346          ADD.L   #2,(IOADDR)         Move memory location past first word
0000231A  6100 FDCA               1347  PRINTS  BSR     DISPSRC             Get source display
0000231E  6608                    1348          BNE     *+10                If source does not exist, skip the next two lines
00002320  183C 0001               1349          MOVE.B  #1,D4               Else, set source to true
00002324  6100 F8A8               1350          BSR     DISPOP              Display accordingly
00002328  6100 FDDC               1351  PRINTD  BSR     DISPDST             Get destination display
0000232C  6600 0018               1352          BNE     PRNTFIN             If dest does not exists, skip to PRINT finish
00002330  103C 0006               1353          MOVE.B  #6,D0               Display character
00002334  123C 002C               1354          MOVE.B  #',',D1             Read comma
00002338  B83C 0001               1355          CMP.B   #1,D4               Test if source was displayed
0000233C  6600 0000               1356          BNE     *+2                 If it was not displayed, don't display a comma
00002340  4E4F                    1357          TRAP    #15                 If it was displayed, display a comma
00002342  6100 F88A               1358          BSR     DISPOP              Display destination accordingly
00002346                          1359  
00002346  103C 000B               1360  PRNTFIN MOVE.B  #11,D0              Position cursor COL/ROW
0000234A  323C 4F00               1361          MOVE.W  #$4F00,D1           Set column to end
0000234E  1238 10B0               1362          MOVE.B  IOLC,D1             Set row to line counter
00002352  5201                    1363          ADD.B   #1,D1               Increment by 1
00002354  4E4F                    1364          TRAP    #15
00002356  103C 0006               1365          MOVE.B  #6,D0               Display character
0000235A  123C 007C               1366          MOVE.B  #'|',D1             Read divider
0000235E  4E4F                    1367          TRAP    #15
00002360  6100 002C               1368          BSR     RESETIO             Reset IO values
00002364  54B8 1000               1369          ADD.L   #$2,(GBUFF)         Advance buffer past instruction
00002368                          1370  
00002368  5238 10B0               1371          ADD.B   #1,IOLC
0000236C  0C38 001E 10B0          1372          CMP.B   #30,IOLC            Compare #30 to line counter
00002372  6700 0054               1373          BEQ     PAUSE               If ==, branch to PAUSE
00002376                          1374  
00002376  6100 0042               1375          BSR     CHKEND              Check for end of program
0000237A                          1376  
0000237A  0C38 0001 10B0          1377          CMP.B   #1,IOLC             Compare #1 to line counter
00002380  6600 012A               1378          BNE     OP                  If !=, branch to OP for next instruction
00002384  21F8 1000 10A4          1379          MOVE.L  (GBUFF),(NGBUFF)    Else, store GBUFF in NGBUFF
0000238A                          1380  
0000238A  6000 0120               1381          BRA     OP                  Branch to OP for next instruction
0000238E                          1382  
0000238E                          1383  * Reset I/O instruction values
0000238E  11FC 00FF 10A8          1384  RESETIO MOVE.B  #$FF,(IOOPCD)
00002394  11FC 00FF 10A9          1385          MOVE.B  #$FF,(IOBDCD)
0000239A  11FC 00FF 10AA          1386          MOVE.B  #$FF,(IOSIZE)
000023A0  11FC 00FF 11C2          1387          MOVE.B  #$FF,(SMD)
000023A6  11FC 00FF 11C3          1388          MOVE.B  #$FF,(SRG)
000023AC  11FC 00FF 11C0          1389          MOVE.B  #$FF,(DMD)
000023B2  11FC 00FF 11C1          1390          MOVE.B  #$FF,(DRG)
000023B8  4E75                    1391          RTS
000023BA                          1392  
000023BA                          1393  * Check if the end of the program has been reached
000023BA  2078 1000               1394  CHKEND  MOVE.L  GBUFF,A0            Set A0 to GBUFF location
000023BE  B1F8 1054               1395          CMPA.L  ELOC,A0             Compare next buffer to ending location
000023C2  6E00 0076               1396          BGT     DONE                Branch to DONE if > ending location
000023C6  4E75                    1397          RTS                         Else, return to caller
000023C8                          1398  
000023C8                          1399  *
000023C8                          1400  * Pause: Halt the instruction display process, and prompt for an action
000023C8                          1401  *
000023C8                          1402  
000023C8  6100 FE02               1403  PAUSE   BSR     NEWLINE             Display new line
000023CC  43F8 1503               1404          LEA     MSSG4,A1            Display keypress prompt
000023D0  103C 000E               1405          MOVE.B  #14,D0              Display A1 until null char
000023D4  4E4F                    1406          TRAP    #15
000023D6                          1407  
000023D6                          1408  *
000023D6                          1409  * Request Key: Request a keyboard input, and do not continue until a valid input was given
000023D6                          1410  *
000023D6                          1411  
000023D6  103C 000C               1412  REQKEY  MOVE.B  #12,D0              Keyboard echo
000023DA  123C 0000               1413          MOVE.B  #0,D1               Hidden
000023DE  4E4F                    1414          TRAP    #15
000023E0  103C 0005               1415          MOVE.B  #5,D0               Request keyboard input
000023E4  4E4F                    1416          TRAP    #15
000023E6  B23C 000D               1417          CMP.B   #$D,D1              Compare input to ENTER
000023EA  6700 0022               1418          BEQ     DSPHDR              If ==, branch to DSPHDR
000023EE  B23C 0008               1419          CMP.B   #$8,D1              Compare input to BACKSPACE
000023F2  6700 0076               1420          BEQ     RESTART             If ==, branch to RESTART
000023F6  B23C 0030               1421          CMP.B   #$30,D1             Compare input to [0]
000023FA  6700 0068               1422          BEQ     HALT                If ==, branch to HALT
000023FE  B23C 000A               1423          CMP.B   #$A,D1              Compare input to CTR + ENTER
00002402  66D2                    1424          BNE     REQKEY              If !=, loop until a recognized key code was entered
00002404  21F8 10A4 1000          1425          MOVE.L  (NGBUFF),(GBUFF)    Else, go down one line
0000240A  6000 0002               1426          BRA     DSPHDR              Branch to DSPHDR
0000240E                          1427  
0000240E                          1428  *
0000240E                          1429  * Display Header: Display the column headers and reset the counters
0000240E                          1430  *
0000240E                          1431  
0000240E  103C 000C               1432  DSPHDR  MOVE.B  #12,D0              Keyboard echo
00002412  123C 0001               1433          MOVE.B  #1,D1               Visible
00002416  4E4F                    1434          TRAP    #15
00002418  103C 000B               1435          MOVE.B  #11,D0              Clear the screen
0000241C  323C FF00               1436          MOVE.W  #$FF00,D1
00002420  4E4F                    1437          TRAP    #15
00002422  43F8 1598               1438          LEA     HEADR,A1            Display header
00002426  103C 000E               1439          MOVE.B  #14,D0              Display A1 until null char
0000242A  4E4F                    1440          TRAP    #15
0000242C  4238 10B0               1441          CLR.B   (IOLC)              Reset line counter
00002430  4238 10B1               1442          CLR.B   (IOBC)              Reset bad counter
00002434  6184                    1443          BSR     CHKEND              Check for end of program        
00002436  6000 0074               1444          BRA     OP                  Branch to OP
0000243A                          1445  
0000243A                          1446  *
0000243A                          1447  * Done: Display the ending message, and halt the program
0000243A                          1448  *
0000243A                          1449  
0000243A  6100 FD90               1450  DONE    BSR     NEWLINE             Display new line
0000243E  43F8 1547               1451          LEA     MSSG5,A1            Display end message
00002442  103C 000E               1452          MOVE.B  #14,D0              Display A1 until null char
00002446  4E4F                    1453          TRAP    #15
00002448  103C 000C               1454          MOVE.B  #12,D0              Keyboard echo
0000244C  123C 0000               1455          MOVE.B  #0,D1               Hidden
00002450  4E4F                    1456          TRAP    #15
00002452  103C 0005               1457          MOVE.B  #5,D0               Request keyboard input
00002456  4E4F                    1458          TRAP    #15
00002458  B23C 0030               1459          CMP.B   #$30,D1             Compare input to 0
0000245C  6700 0006               1460          BEQ     HALT                If ==, branch to halt
00002460                          1461  
00002460  6000 0008               1462          BRA     RESTART
00002464                          1463  
00002464                          1464  *
00002464                          1465  * Halt: Halt the program
00002464                          1466  *
00002464                          1467  
00002464  103C 0009               1468  HALT    MOVE.B  #9,D0               Terminate the program
00002468  4E4F                    1469          TRAP    #15
0000246A                          1470  
0000246A                          1471  *
0000246A                          1472  * Restart: Restart the program
0000246A                          1473  *
0000246A                          1474  
0000246A  103C 000B               1475  RESTART MOVE.B  #11,D0              Clear the screen
0000246E  323C FF00               1476          MOVE.W  #$FF00,D1
00002472  4E4F                    1477          TRAP    #15
00002474  103C 000C               1478          MOVE.B  #12,D0              Keyboard echo
00002478  123C 0001               1479          MOVE.B  #1,D1               Visible
0000247C  4E4F                    1480          TRAP    #15
0000247E  42B8 1000               1481          CLR.L   (GBUFF)             Reset GBUFF
00002482  42B8 1004               1482          CLR.L   (SLOC)              Reset starting location
00002486  42B8 1054               1483          CLR.L   (ELOC)              Reset ending location
0000248A  2E7C 01000000           1484          MOVEA.L #$01000000,A7       Reset stack pointer
00002490  6000 F222               1485          BRA     START
00002494                          1486  
00002494                          1487  *--------------------
00002494                          1488  *   OP
00002494                          1489  *--------------------
00002494                          1490  
00002494                          1491  *
00002494                          1492  * Jump Mask: Use CMPMSK, and jumps to the OP branch if it returns true
00002494                          1493  * Input CMPMSK inputs, input A0 for OP branch
00002494                          1494  *
00002494                          1495  
00002494  6100 F37A               1496  JMPMSK  BSR     CMPMSK              Branch to CMPMSK
00002498  6610                    1497          BNE.S   *+18                If the bits did not match, return to caller
0000249A  4E90                    1498          JSR     (A0)                If the bits matched, branch to the OP address
0000249C  660A                    1499          BNE     *+12                If the OP address was read successful, skip the next two lines
0000249E  21C9 1000               1500          MOVE.L  A1,(GBUFF)          The buffer was good, move it to GBUFF
000024A2  6000 FD9A               1501          BRA     PRINT               Branch to PRINT     
000024A6  2278 1000               1502          MOVE.L  GBUFF,A1            The buffer was bad, restore A1
000024AA  4E75                    1503          RTS                         Return to caller for next instruction
000024AC                          1504  
000024AC  2078 1000               1505  OP      MOVE.L  GBUFF,A0            Set A0 to GBUFF location
000024B0  2278 1000               1506          MOVE.L  GBUFF,A1            Set A1 to GBUFF location for sub-routines
000024B4  143C 0000               1507          MOVE.B  #0,D2               Set NULL count to 0
000024B8  0C90 FFFFFFFF           1508          CMP.L   #$FFFFFFFF,(A0)     Check for NULL
000024BE  6602                    1509          BNE     *+4                 If !==, skip next line
000024C0  5202                    1510          ADD.B   #1,D2               Else, increment NULL count
000024C2  3018                    1511          MOVE.W  (A0)+,D0            Transfer word data to D0, post-increment location
000024C4  3218                    1512          MOVE.W  (A0)+,D1            Transfer next word data to D1, post-increment location
000024C6  0C90 FFFFFFFF           1513          CMP.L   #$FFFFFFFF,(A0)     Check for NULL
000024CC  6602                    1514          BNE     *+4                 If !==, skip next line
000024CE  5202                    1515          ADD.B   #1,D2               Else, increment NULL count
000024D0  B43C 0002               1516          CMP.B   #2,D2               Compare NULL count to 2
000024D4  6700 FF64               1517          BEQ     DONE                If ==, branch to DONE
000024D8  21F8 1000 10AC          1518          MOVE.L  GBUFF,IOADDR        Else, Set memory location for IO
000024DE                          1519  *-----
000024DE                          1520  * 0000
000024DE                          1521  *-----
000024DE                          1522          * ORI:    00000000XXXXXXXX
000024DE  343C 0000               1523          MOVE.W  #%0000000000000000,D2
000024E2  363C FF00               1524          MOVE.W  #%1111111100000000,D3
000024E6  207C 00002A78           1525          MOVE.L  #BRORI,A0
000024EC  61A6                    1526          BSR     JMPMSK
000024EE                          1527  
000024EE                          1528          * ANDI:   00000010XXXXXXXX
000024EE  343C 0200               1529          MOVE.W  #%0000001000000000,D2
000024F2  363C FD00               1530          MOVE.W  #%1111110100000000,D3
000024F6  207C 00002A80           1531          MOVE.L  #BRANDI,A0
000024FC  6196                    1532          BSR     JMPMSK
000024FE                          1533  
000024FE                          1534          * SUBI:   00000100XXXXXXXX
000024FE  343C 0400               1535          MOVE.W  #%0000010000000000,D2
00002502  363C FB00               1536          MOVE.W  #%1111101100000000,D3
00002506  207C 00002A8A           1537          MOVE.L  #BRSUBI,A0
0000250C  6186                    1538          BSR     JMPMSK
0000250E                          1539  
0000250E                          1540          * ADDI:   00000110XXXXXXXX
0000250E  343C 0600               1541          MOVE.W  #%0000011000000000,D2
00002512  363C F900               1542          MOVE.W  #%1111100100000000,D3
00002516  207C 00002A94           1543          MOVE.L  #BRADDI,A0
0000251C  6100 FF76               1544          BSR     JMPMSK
00002520                          1545  
00002520                          1546          * BTST:   0000100000XXXXXX
00002520  343C 0800               1547          MOVE.W  #%0000100000000000,D2
00002524  363C F7C0               1548          MOVE.W  #%1111011111000000,D3
00002528  207C 00002C4E           1549          MOVE.L  #BRBTST,A0
0000252E  6100 FF64               1550          BSR     JMPMSK
00002532                          1551  
00002532                          1552          * EORI:   00001010XXXXXXXX
00002532  343C 0A00               1553          MOVE.W  #%0000101000000000,D2
00002536  363C F500               1554          MOVE.W  #%1111010100000000,D3
0000253A  207C 00002A9E           1555          MOVE.L  #BREORI,A0
00002540  6100 FF52               1556          BSR     JMPMSK
00002544                          1557  
00002544                          1558          * CMPI:   00001100XXXXXXXX
00002544  343C 0C00               1559          MOVE.W  #%0000110000000000,D2
00002548  363C F300               1560          MOVE.W  #%1111001100000000,D3
0000254C  207C 00002AA8           1561          MOVE.L  #BRCMPI,A0
00002552  6100 FF40               1562          BSR     JMPMSK
00002556                          1563  
00002556                          1564          * BTST:   0000XXX100XXXXXX
00002556  343C 0100               1565          MOVE.W  #%0000000100000000,D2
0000255A  363C F0C0               1566          MOVE.W  #%1111000011000000,D3
0000255E  207C 00002C4E           1567          MOVE.L  #BRBTST,A0
00002564  6100 FF2E               1568          BSR     JMPMSK
00002568                          1569  
00002568                          1570  *-----
00002568                          1571  * 0001
00002568                          1572  *-----
00002568                          1573          * MOVE.B: 0001XXXXXXXXXXXX
00002568  343C 1000               1574          MOVE.W  #%0001000000000000,D2
0000256C  363C E000               1575          MOVE.W  #%1110000000000000,D3
00002570  207C 00002F26           1576          MOVE.L  #BRMOVE,A0
00002576  6100 FF1C               1577          BSR     JMPMSK
0000257A                          1578  *-----
0000257A                          1579  * 0010
0000257A                          1580  *-----
0000257A                          1581          * MOVE.L: 0010XXXXXXXXXXXX
0000257A  343C 2000               1582          MOVE.W  #%0010000000000000,D2
0000257E  363C D000               1583          MOVE.W  #%1101000000000000,D3
00002582  207C 00002F26           1584          MOVE.L  #BRMOVE,A0
00002588  6100 FF0A               1585          BSR     JMPMSK
0000258C                          1586  *-----
0000258C                          1587  * 0011
0000258C                          1588  *-----
0000258C                          1589          * MOVE.W: 0011XXXXXXXXXXXX 
0000258C  343C 3000               1590          MOVE.W  #%0011000000000000,D2
00002590  363C C000               1591          MOVE.W  #%1100000000000000,D3
00002594  207C 00002F26           1592          MOVE.L  #BRMOVE,A0
0000259A  6100 FEF8               1593          BSR     JMPMSK
0000259E                          1594  *-----
0000259E                          1595  * 0100
0000259E                          1596  *-----
0000259E                          1597          * NOT:    01000110XXXXXXXX
0000259E  343C 4600               1598          MOVE.W  #%0100011000000000,D2
000025A2  363C B900               1599          MOVE.W  #%1011100100000000,D3
000025A6  207C 000031D4           1600          MOVE.L  #BRNOT,A0
000025AC  6100 FEE6               1601          BSR     JMPMSK
000025B0                          1602  
000025B0                          1603          * MOVEM:  01001X001XXXXXXX
000025B0  343C 4880               1604          MOVE.W  #%0100100010000000,D2
000025B4  363C B300               1605          MOVE.W  #%1011001100000000,D3
000025B8  207C 00002FC8           1606          MOVE.L  #BRMOVEM,A0
000025BE  6100 FED4               1607          BSR     JMPMSK
000025C2                          1608  
000025C2                          1609          * ILLEGAL:0100101011111100
000025C2  343C 4AFC               1610          MOVE.W  #%0100101011111100,D2
000025C6  363C B503               1611          MOVE.W  #%1011010100000011,D3
000025CA  207C 0000323C           1612          MOVE.L  #BRILLEGAL,A0
000025D0  6100 FEC2               1613          BSR     JMPMSK
000025D4                          1614  
000025D4                          1615          * NOP:    0100111001110001
000025D4  343C 4E71               1616          MOVE.W  #%0100111001110001,D2
000025D8  363C B18E               1617          MOVE.W  #%1011000110001110,D3
000025DC  207C 00003232           1618          MOVE.L  #BRNOP,A0
000025E2  6100 FEB0               1619          BSR     JMPMSK
000025E6                          1620  
000025E6                          1621          * RTE:    0100111001110011
000025E6  343C 4E73               1622          MOVE.W  #%0100111001110011,D2
000025EA  363C B18C               1623          MOVE.W  #%1011000110001100,D3
000025EE  207C 00003214           1624          MOVE.L  #BRRTE,A0
000025F4  6100 FE9E               1625          BSR     JMPMSK
000025F8                          1626  
000025F8                          1627          * RTD:    0100111001110100
000025F8  343C 4E74               1628          MOVE.W  #%0100111001110100,D2
000025FC  363C B18B               1629          MOVE.W  #%1011000110001011,D3
00002600  207C 0000321E           1630          MOVE.L  #BRRTD,A0
00002606  6100 FE8C               1631          BSR     JMPMSK
0000260A                          1632  
0000260A                          1633          * RTS:    0100111001110101
0000260A  343C 4E75               1634          MOVE.W  #%0100111001110101,D2
0000260E  363C B18A               1635          MOVE.W  #%1011000110001010,D3
00002612  207C 0000320A           1636          MOVE.L  #BRRTS,A0
00002618  6100 FE7A               1637          BSR     JMPMSK
0000261C                          1638  
0000261C                          1639          * RTR:    0100111001110111
0000261C  343C 4E77               1640          MOVE.W  #%0100111001110111,D2
00002620  363C B188               1641          MOVE.W  #%1011000110001000,D3
00002624  207C 00003228           1642          MOVE.L  #BRRTR,A0
0000262A  6100 FE68               1643          BSR     JMPMSK
0000262E                          1644  
0000262E                          1645          * JSR:    0100111010XXXXXX
0000262E  343C 4E80               1646          MOVE.W  #%0100111010000000,D2
00002632  363C B140               1647          MOVE.W  #%1011000101000000,D3
00002636  207C 00002EEA           1648          MOVE.L  #BRJSR,A0
0000263C  6100 FE56               1649          BSR     JMPMSK
00002640                          1650      
00002640                          1651          * JMP:    0100111011XXXXXX
00002640  343C 4EC0               1652          MOVE.W  #%0100111011000000,D2
00002644  363C B100               1653          MOVE.W  #%1011000100000000,D3
00002648  207C 00002F08           1654          MOVE.L  #BRJMP,A0
0000264E  6100 FE44               1655          BSR     JMPMSK
00002652                          1656  
00002652                          1657          * LEA:    0100XXX111XXXXXX
00002652  343C 41C0               1658          MOVE.W  #%0100000111000000,D2
00002656  363C B000               1659          MOVE.W  #%1011000000000000,D3
0000265A  207C 00002EC2           1660          MOVE.L  #BRLEA,A0
00002660  6100 FE32               1661          BSR     JMPMSK
00002664                          1662  *-----
00002664                          1663  * 0101
00002664                          1664  *-----
00002664                          1665          * ADDQ:   0101XXX0XXXXXXXX
00002664  343C 5000               1666          MOVE.W  #%0101000000000000,D2
00002668  363C A100               1667          MOVE.W  #%1010000100000000,D3
0000266C  207C 00002B2A           1668          MOVE.L  #BRADDQ,A0
00002672  6100 FE20               1669          BSR     JMPMSK
00002676                          1670  
00002676                          1671          * SUBQ:   0101XXX1XXXXXXXX
00002676  343C 5100               1672          MOVE.W  #%0101000100000000,D2
0000267A  363C A000               1673          MOVE.W  #%1010000000000000,D3
0000267E  207C 00002BAC           1674          MOVE.L  #BRSUBQ,A0
00002684  6100 FE0E               1675          BSR     JMPMSK
00002688                          1676  *-----
00002688                          1677  * 0110
00002688                          1678  *-----
00002688                          1679          * Bcc:    0110XXXXXXXXXXXX
00002688  343C 6000               1680          MOVE.W  #%0110000000000000,D2
0000268C  363C 9000               1681          MOVE.W  #%1001000000000000,D3
00002690  207C 00002CF4           1682          MOVE.L  #BRBccd,A0
00002696  6100 FDFC               1683          BSR     JMPMSK
0000269A                          1684  *-----
0000269A                          1685  * 0111
0000269A                          1686  *-----
0000269A                          1687          * MOVEQ:  0111XXX0XXXXXXXX
0000269A  343C 7000               1688          MOVE.W  #%0111000000000000,D2
0000269E  363C 8100               1689          MOVE.W  #%1000000100000000,D3
000026A2  207C 00003064           1690          MOVE.L  #BRMOVEQ,A0
000026A8  6100 FDEA               1691          BSR     JMPMSK
000026AC                          1692  *-----
000026AC                          1693  * 1000
000026AC                          1694  *-----
000026AC                          1695          * DIVU:   1000XXX011XXXXXX
000026AC  343C 80C0               1696          MOVE.W  #%1000000011000000,D2
000026B0  363C 7100               1697          MOVE.W  #%0111000100000000,D3
000026B4  207C 00003190           1698          MOVE.L  #BRDIVU,A0
000026BA  6100 FDD8               1699          BSR     JMPMSK
000026BE                          1700  
000026BE                          1701          * DIVS:   1000XXX111XXXXXX
000026BE  343C 81C0               1702          MOVE.W  #%1000000111000000,D2
000026C2  363C 7000               1703          MOVE.W  #%0111000000000000,D3
000026C6  207C 000031A0           1704          MOVE.L  #BRDIVS,A0
000026CC  6100 FDC6               1705          BSR     JMPMSK
000026D0                          1706  
000026D0                          1707          * OR:     1000XXXXXXXXXXXX
000026D0  343C 8000               1708          MOVE.W  #%1000000000000000,D2
000026D4  363C 7000               1709          MOVE.W  #%0111000000000000,D3
000026D8  207C 00002C02           1710          MOVE.L  #BROR,A0
000026DE  6100 FDB4               1711          BSR     JMPMSK
000026E2                          1712  *-----
000026E2                          1713  * 1001
000026E2                          1714  *-----
000026E2                          1715          * SUB:    1001XXXXXXXXXXXX
000026E2  343C 9000               1716          MOVE.W  #%1001000000000000,D2
000026E6  363C 6000               1717          MOVE.W  #%0110000000000000,D3
000026EA  207C 00002B34           1718          MOVE.L  #BRSUB,A0
000026F0  6100 FDA2               1719          BSR     JMPMSK
000026F4                          1720  *-----
000026F4                          1721  * 1010
000026F4                          1722  *-----
000026F4                          1723  *-----
000026F4                          1724  * 1011
000026F4                          1725  *-----
000026F4                          1726          * CMP:    1011XXXXXXXXXXXX
000026F4  343C B000               1727          MOVE.W  #%1011000000000000,D2
000026F8  363C 4000               1728          MOVE.W  #%0100000000000000,D3
000026FC  207C 00002E26           1729          MOVE.L  #BRCMP,A0
00002702  6100 FD90               1730          BSR     JMPMSK
00002706                          1731  
00002706                          1732          * EOR:    1011XXXXXXXXXXXX
00002706  343C B000               1733          MOVE.W  #%1011000000000000,D2
0000270A  363C 4000               1734          MOVE.W  #%0100000000000000,D3
0000270E  207C 00002E8C           1735          MOVE.L  #BREOR,A0
00002714  6100 FD7E               1736          BSR     JMPMSK
00002718                          1737  *-----
00002718                          1738  * 1100
00002718                          1739  *-----
00002718                          1740          * AND:    1100XXXXXXXXXXXX
00002718  343C C000               1741          MOVE.W  #%1100000000000000,D2
0000271C  363C 3000               1742          MOVE.W  #%0011000000000000,D3
00002720  207C 00002BB6           1743          MOVE.L  #BRAND,A0
00002726  6100 FD6C               1744          BSR     JMPMSK
0000272A                          1745  
0000272A                          1746          * MULU:   1100XXX011XXXXXX
0000272A  343C C0C0               1747          MOVE.W  #%1100000011000000,D2
0000272E  363C 3100               1748          MOVE.W  #%0011000100000000,D3
00002732  207C 00003170           1749          MOVE.L  #BRMULU,A0
00002738  6100 FD5A               1750          BSR     JMPMSK
0000273C                          1751  
0000273C                          1752          * MULS:   1100XXX111XXXXXX
0000273C  343C C1C0               1753          MOVE.W  #%1100000111000000,D2
00002740  363C 3000               1754          MOVE.W  #%0011000000000000,D3
00002744  207C 00003180           1755          MOVE.L  #BRMULS,A0
0000274A  6100 FD48               1756          BSR     JMPMSK
0000274E                          1757  *-----
0000274E                          1758  * 1101
0000274E                          1759  *-----
0000274E                          1760          * ADD:    1101XXXXXXXXXXXX
0000274E  343C D000               1761          MOVE.W  #%1101000000000000,D2
00002752  363C 2000               1762          MOVE.W  #%0010000000000000,D3
00002756  207C 00002AB2           1763          MOVE.L  #BRADD,A0
0000275C  6100 FD36               1764          BSR     JMPMSK
00002760                          1765  *-----
00002760                          1766  * 1110
00002760                          1767  *-----
00002760                          1768          * ASL/ASR:1110XXXXXXX00XXX
00002760  343C E000               1769          MOVE.W  #%1110000000000000,D2
00002764  363C 1018               1770          MOVE.W  #%0001000000011000,D3
00002768  207C 0000308A           1771          MOVE.L  #BRASd,A0
0000276E  6100 FD24               1772          BSR     JMPMSK
00002772                          1773  
00002772                          1774          * LSL/LSR:1110XXXXXXX01XXX
00002772  343C E008               1775          MOVE.W  #%1110000000001000,D2
00002776  363C 1010               1776          MOVE.W  #%0001000000010000,D3
0000277A  207C 000030BA           1777          MOVE.L  #BRLSd,A0
00002780  6100 FD12               1778          BSR     JMPMSK
00002784                          1779  
00002784                          1780          * ASL/ASR:1110000X11XXXXXX
00002784  343C E0C0               1781          MOVE.W  #%1110000011000000,D2
00002788  363C 1E00               1782          MOVE.W  #%0001111000000000,D3
0000278C  207C 0000308A           1783          MOVE.L  #BRASd,A0
00002792  6100 FD00               1784          BSR     JMPMSK
00002796                          1785  
00002796                          1786          * LSL/LSR:1110001X11XXXXXX
00002796  343C E2C0               1787          MOVE.W  #%1110001011000000,D2
0000279A  363C 1C00               1788          MOVE.W  #%0001110000000000,D3
0000279E  207C 000030BA           1789          MOVE.L  #BRLSd,A0
000027A4  6100 FCEE               1790          BSR     JMPMSK
000027A8                          1791  *-----
000027A8                          1792  * 1111
000027A8                          1793  *-----     
000027A8  6000 FA54               1794          BRA     BRBAD           No mask matched, branch to PRINT
000027AC                          1795  
000027AC                          1796  *--------------------------
000027AC                          1797  *  Instruction Subroutines
000027AC                          1798  *--------------------------
000027AC                          1799  
000027AC                          1800  *
000027AC                          1801  * Test Addressing Modes: Tests last register and mode for valid addressing modes
000027AC                          1802  * Input valid modes in D0.W, output found addressing mode to D1.B, or FF if not found
000027AC                          1803  * Set Z-flag if mode was valid, or clear Z-flag if mode was invalid
000027AC                          1804  *
000027AC                          1805  * D0.W addressing modes (set to 0 for invalid, 1 for valid):
000027AC                          1806  *   0   Dn
000027AC                          1807  *   1   An
000027AC                          1808  *   2   (An)
000027AC                          1809  *   3   (An)+
000027AC                          1810  *   4   -(An)
000027AC                          1811  *   5   (d,An)
000027AC                          1812  *   6   (d,An,Xn)
000027AC                          1813  *   7   (xxx).W
000027AC                          1814  *   8   (xxx).L
000027AC                          1815  *   9   (d,PC)
000027AC                          1816  *   A   (d,PC,Xn)
000027AC                          1817  *   B   #<data>
000027AC                          1818  *
000027AC                          1819  * Modes         %XXXXBA9876543210
000027AC  =00000FFF               1820  M_ALL   EQU     %0000111111111111   All modes
000027AC  =00000FFD               1821  M_DAT   EQU     %0000111111111101   Data modes
000027AC  =00000FFC               1822  M_MEM   EQU     %0000111111111100   Memory modes
000027AC  =000007E4               1823  M_CTR   EQU     %0000011111100100   Control modes
000027AC  =0000007F               1824  M_ALT   EQU     %0000000001111111   Alterable modes
000027AC  =000001FC               1825  M_MALT  EQU     %0000000111111100   Memory alterable modes
000027AC  =000001FD               1826  M_DALT  EQU     %0000000111111101   Data alterable modes
000027AC  =000001FF               1827  M_EAALT EQU     %0000000111111111   EA alterable modes
000027AC                          1828  
000027AC  1F02                    1829  TSTAM   MOVE.B  D2,-(SP)        Push D2 to stack
000027AE  4281                    1830          CLR.L   D1
000027B0  1238 11C4               1831          MOVE.B  (RGMD),D1       Move REGMOD to D1
000027B4  1401                    1832          MOVE.B  D1,D2           Copy REGMOD to D2
000027B6  EB09                    1833          LSL.B   #5,D1
000027B8  EA09                    1834          LSR.B   #5,D1           D1 = Mode
000027BA  E60A                    1835          LSR.B   #3,D2           D2 = Register
000027BC  B23C 0007               1836          CMP.B   #%111,D1        Test mode to 111
000027C0  6602                    1837          BNE     *+4             If !=, skip next line
000027C2  D202                    1838          ADD.B   D2,D1           Add register to mode-- effectively creating a 4 bit mode
000027C4  0300                    1839          BTST    D1,D0           Test mode for validity
000027C6  6706                    1840          BEQ     *+8             If it is invalid, skip to clear flag
000027C8  141F                    1841          MOVE.B  (SP)+,D2        If it is valid, restore D2
000027CA  6000 EF02               1842          BRA     FLAGST          Set flag & return to caller
000027CE  141F                    1843          MOVE.B  (SP)+,D2        Restore D2
000027D0  6000 EF02               1844          BRA     FLAGCL          Clear flag & return to caller
000027D4                          1845  
000027D4                          1846  *
000027D4                          1847  * Advance Buffer: Advances buffer based on last register and mode
000027D4                          1848  * Input buffer in A1, reg & mode in RGMD, output displacement to DIS
000027D4                          1849  *
000027D4                          1850  
000027D4  48E7 6000               1851  ADVBFR  MOVEM.L D1/D2,-(SP)     Push D1 & D2 to the stack
000027D8  11FC 00FF 11C5          1852          MOVE.B  #$FF,(DIS)      Set displacement to NULL
000027DE  1238 11C4               1853          MOVE.B  (RGMD),D1       Move Reg & Mod to D1
000027E2  2409                    1854          MOVE.L  A1,D2           Copy buffer to D2
000027E4  B23C 0007               1855          CMP.B   #$07,D1         Test 000 111 = (XXX).W (Word)
000027E8  6602                    1856          BNE.S   *+4             Skip next line
000027EA  5489                    1857          ADD.L   #2,A1           Advance buffer by word
000027EC  B23C 000F               1858          CMP.B   #$0F,D1         Test 001 111 = (XXX).L (Long)
000027F0  6602                    1859          BNE.S   *+4             Skip next line
000027F2  5889                    1860          ADD.L   #4,A1           Advance buffer by long
000027F4  B23C 0017               1861          CMP.B   #$17,D1         Test 010 111 = (d16,PC) (Word)
000027F8  6602                    1862          BNE.S   *+4             Skip next line
000027FA  5489                    1863          ADD.L   #2,A1           Advance buffer by word
000027FC  B23C 001F               1864          CMP.B   #$1F,D1         Test 011 111 = (d8,PC,Xn) (Word)
00002800  6602                    1865          BNE.S   *+4             Skip next line
00002802  5489                    1866          ADD.L   #2,A1           Advance buffer by word
00002804  B23C 0027               1867          CMP.B   #$27,D1         Test 100 111 = Immediate (OP code size)
00002808  6700 0024               1868          BEQ     ADVBSZ          If ==, branch to Advance Buffer by Size
0000280C  EB09                    1869          LSL.B   #5,D1           Else, check the mode...
0000280E  EA09                    1870          LSR.B   #5,D1           D1 = Mode
00002810  B23C 0005               1871          CMP.B   #5,D1           Test XXX 101 = (d16,An) (Word)
00002814  6602                    1872          BNE     *+4             Skip next line
00002816  5489                    1873          ADD.L   #2,A1           Advance buffer by word
00002818  B23C 0006               1874          CMP.B   #6,D1           Test XXX 110 = (d8,An,Xn) (Word)
0000281C  6602                    1875          BNE     *+4             Skip next line
0000281E  5489                    1876          ADD.L   #2,A1           Advance buffer by word
00002820  4482                    1877          NEG.L   D2              Negate original buffer
00002822  D489                    1878          ADD.L   A1,D2           Add buffer to get difference
00002824  11C2 11C5               1879          MOVE.B  D2,(DIS)        Store displacement in DIS
00002828  4CDF 0006               1880          MOVEM.L (SP)+,D1/D2     Restore D1 & D2
0000282C  4E75                    1881          RTS                     Return to caller
0000282E                          1882  
0000282E                          1883  *
0000282E                          1884  * Advance Buffer by Size: Advances buffer based on instruction size
0000282E                          1885  * Input buffer in A1, input size from (IOSIZE), output displacement to DIS
0000282E                          1886  *
0000282E                          1887  
0000282E  0C38 00FF 11C5          1888  ADVBSZ  CMP.B   #$FF,(DIS)      Check if DIS is NULL (255 is odd so displacement should never be FF)
00002834  6704                    1889          BEQ     *+6             If it is null, values have already been pushed to the stack, skip the next line
00002836  48E7 6000               1890          MOVEM.L D1/D2,-(SP)     Else, push D1 & D2 to the stack
0000283A  1238 10AA               1891          MOVE.B  (IOSIZE),D1     Read size to D1
0000283E  2409                    1892          MOVE.L  A1,D2           Copy buffer to D2
00002840  B23C 0000               1893          CMP.B   #0,D1           Test 0 = Byte
00002844  6602                    1894          BNE.S   *+4             Skip next line
00002846  5489                    1895          ADD.L   #2,A1           Advance buffer by word (00BB)
00002848  B23C 0001               1896          CMP.B   #1,D1           Test 1 = Word
0000284C  6602                    1897          BNE.S   *+4             Skip next line
0000284E  5489                    1898          ADD.L   #2,A1           Advance buffer by word        
00002850  B23C 0002               1899          CMP.B   #2,D1           Test 2 = Long
00002854  6602                    1900          BNE.S   *+4             Skip next line
00002856  5889                    1901          ADD.L   #4,A1           Advance buffer by long
00002858  4442                    1902          NEG     D2              Negate original buffer
0000285A  D489                    1903          ADD.L   A1,D2           Add buffer to get difference
0000285C  11C2 11C5               1904          MOVE.B  D2,(DIS)        Store displacement in DIS
00002860  4CDF 0006               1905          MOVEM.L (SP)+,D2/D1     Restore D1 and D2
00002864  4E75                    1906          RTS                     Return to caller
00002866                          1907  
00002866                          1908  *
00002866                          1909  * OP Size: Test the standard OP size code
00002866                          1910  * Inputs size from (DMD), outputs size to IOSIZE, operation to D2.B, correct mode to DMD
00002866                          1911  * OPM (OP-MODE):  Byte | Word | Long | Operation | D2.B
00002866                          1912  *                  000 |  001 |  010 |   <ea>,Dn |    0
00002866                          1913  *                  100 |  101 |  110 |   Dn,<ea> |    1
00002866                          1914  *                         011 |  111 |   <ea>,An |    2
00002866                          1915  *
00002866                          1916  
00002866  48E7 C000               1917  OPSIZE  MOVEM.L D0/D1,-(SP)     Push D0 & D1 to stack
0000286A  4241                    1918          CLR.W   D1              Ensure displacement will be <= 7
0000286C  1238 11C0               1919          MOVE.B  (DMD),D1        Get destination mode in D1
00002870  C2FC 0004               1920          MULU.W  #4,D1           Convert to displacement
00002874  4EFB 1002               1921          JMP     OPTBL(PC,D1.W)  Jump to OP mode
00002878  6000 001E               1922  OPTBL   BRA     OP0             000
0000287C  6000 002C               1923          BRA     OP1             001
00002880  6000 003A               1924          BRA     OP2             010
00002884  6000 0048               1925          BRA     OP3             011
00002888  6000 0056               1926          BRA     OP4             100
0000288C  6000 0064               1927          BRA     OP5             101
00002890  6000 0072               1928          BRA     OP6             110
00002894  6000 0080               1929          BRA     OP7             111
00002898  143C 0000               1930  OP0     MOVE.B  #0,D2           Set OP to 0 for Dn
0000289C  11FC 0000 11C0          1931          MOVE.B  #0,(DMD)        Set mode to Dn
000028A2  103C 0000               1932          MOVE.B  #0,D0           Set size to byte
000028A6  6000 0080               1933          BRA     OP8             Branch to end
000028AA  143C 0000               1934  OP1     MOVE.B  #0,D2           Set OP to 0 for Dn
000028AE  11FC 0000 11C0          1935          MOVE.B  #0,(DMD)        Set mode to Dn
000028B4  103C 0001               1936          MOVE.B  #1,D0           Set size to word
000028B8  6000 006E               1937          BRA     OP8             Branch to end
000028BC  143C 0000               1938  OP2     MOVE.B  #0,D2           Set OP to 0 for Dn
000028C0  11FC 0000 11C0          1939          MOVE.B  #0,(DMD)        Set mode to Dn
000028C6  103C 0002               1940          MOVE.B  #2,D0           Set size to long
000028CA  6000 005C               1941          BRA     OP8             Branch to end
000028CE  143C 0002               1942  OP3     MOVE.B  #2,D2           Set OP to 2 for An
000028D2  11FC 0001 11C0          1943          MOVE.B  #1,(DMD)        Set mode to An
000028D8  103C 0001               1944          MOVE.B  #1,D0           Set size to word
000028DC  6000 004A               1945          BRA     OP8             Branch to end
000028E0  143C 0001               1946  OP4     MOVE.B  #1,D2           Set OP to 1 for <ea>
000028E4  11FC 0000 11C0          1947          MOVE.B  #0,(DMD)        Set mode to Dn
000028EA  103C 0000               1948          MOVE.B  #0,D0           Set size to byte
000028EE  6000 0038               1949          BRA     OP8             Branch to end
000028F2  143C 0001               1950  OP5     MOVE.B  #1,D2           Set OP to 1 for <ea>
000028F6  11FC 0000 11C0          1951          MOVE.B  #0,(DMD)        Set mode to Dn
000028FC  103C 0001               1952          MOVE.B  #1,D0           Set size to word
00002900  6000 0026               1953          BRA     OP8             Branch to end
00002904  143C 0001               1954  OP6     MOVE.B  #1,D2           Set OP to 1 for <ea>
00002908  11FC 0000 11C0          1955          MOVE.B  #0,(DMD)        Set mode to Dn
0000290E  103C 0002               1956          MOVE.B  #2,D0           Set size to long
00002912  6000 0014               1957          BRA     OP8             Branch to end
00002916  143C 0002               1958  OP7     MOVE.B  #2,D2           Set OP to 2 for An
0000291A  11FC 0001 11C0          1959          MOVE.B  #1,(DMD)        Set mode to An
00002920  103C 0002               1960          MOVE.B  #2,D0           Set size to long
00002924  6000 0002               1961          BRA     OP8             Branch to end
00002928  11C0 10AA               1962  OP8     MOVE.B  D0,(IOSIZE)     Store size in IOSIZE
0000292C  1238 11C1               1963          MOVE.B  (DRG),D1        Move DRG to D1
00002930  E709                    1964          LSL.B   #3,D1           Shift the reg 3 bits left
00002932  8238 11C0               1965          OR.B    (DMD),D1        Add mode after reg
00002936  11C1 11C4               1966          MOVE.B  D1,(RGMD)       Store D1 in RGMD
0000293A  4CDF 0003               1967          MOVEM.L (SP)+,D0/D1     Restore D0 & D1
0000293E  4E75                    1968          RTS                     Return to caller
00002940                          1969  
00002940                          1970  *
00002940                          1971  * Extract destination: Extracts destination mode to DMD and destination register to DRG from instruction
00002940                          1972  * Input instruction from GBUFF, output a combination of reg & mode in RGMD
00002940                          1973  *
00002940                          1974  
00002940  48E7 E080               1975  EXDST   MOVEM.L D0-D2/A0,-(SP)  Push D0 - D2 and A0 to stack
00002944  2078 1000               1976          MOVE.L  GBUFF,A0        Point A0 to GBUFF
00002948  3010                    1977          MOVE.W  (A0),D0         Move instruction to D0
0000294A  243C 000001C0           1978          MOVE.L  #$1C0,D2        Extract dest mode at 0000000111000000
00002950  6100 EEEC               1979          BSR     EXTMSK          Get dest mode to D1
00002954  11C1 11C0               1980          MOVE.B  D1,(DMD)        Move dest mode to DMD
00002958  243C 00000E00           1981          MOVE.L  #$E00,D2        Extract dest reg at 0000111000000000
0000295E  6100 EEDE               1982          BSR     EXTMSK          Get dest reg to D1
00002962  11C1 11C1               1983          MOVE.B  D1,(DRG)        Move dest reg to (DRG)
00002966  E709                    1984          LSL.B   #3,D1           Shift the reg 3 bits left
00002968  8238 11C0               1985          OR.B    (DMD),D1        Add mode after reg
0000296C  11C1 11C4               1986          MOVE.B  D1,(RGMD)       Store D1 in RGMD
00002970  4CDF 0107               1987          MOVEM.L (SP)+,D0-D2/A0  Restore D0 - D2 and A0
00002974  4E75                    1988          RTS                     Return to caller
00002976                          1989  
00002976                          1990  *
00002976                          1991  * Extract source: Extracts source mode to SMD and source register to SRG from instruction
00002976                          1992  * Inputs instruction from GBUFF, output a combination of reg & mode in RGMD
00002976                          1993  *
00002976                          1994  
00002976  48E7 E080               1995  EXSRC   MOVEM.L D0-D2/A0,-(SP)  Push D0 - D2 and A0 to stack
0000297A  2078 1000               1996          MOVE.L  GBUFF,A0        Point A0 to GBUFF
0000297E  3010                    1997          MOVE.W  (A0),D0         Move instruction to D0
00002980  7438                    1998          MOVE.L  #$38,D2         Extract src mode at 0000000000111000
00002982  6100 EEBA               1999          BSR     EXTMSK          Get src mode to D1
00002986  11C1 11C2               2000          MOVE.B  D1,(SMD)        Move src mode to (OMD)
0000298A  7407                    2001          MOVE.L  #$7,D2          Extract src reg at 0000000000000111
0000298C  6100 EEB0               2002          BSR     EXTMSK          Get src reg to D1
00002990  11C1 11C3               2003          MOVE.B  D1,(SRG)        Move src reg to (ORG)
00002994  E709                    2004          LSL.B   #3,D1           Shift the reg 3 bits left
00002996  8238 11C2               2005          OR.B    (SMD),D1        Add mode after reg
0000299A  11C1 11C4               2006          MOVE.B  D1,(RGMD)       Store D1 in RGMD
0000299E  4CDF 0107               2007          MOVEM.L (SP)+,D0-D2/A0  Restore D0 - D2
000029A2  4E75                    2008          RTS                     Return to caller
000029A4                          2009  
000029A4                          2010  * Swap fields: Swaps the destination and source fields
000029A4  48A7 C000               2011  SWAPF   MOVEM.W D0/D1,-(SP)     Push D0 and D1 to stack
000029A8  1038 11C0               2012          MOVE.B  (DMD),D0        Store DMD in D0
000029AC  1238 11C1               2013          MOVE.B  (DRG),D1        Store DRG in D1
000029B0  11F8 11C2 11C0          2014          MOVE.B  (SMD),(DMD)     Move SMD to DMD
000029B6  11F8 11C3 11C1          2015          MOVE.B  (SRG),(DRG)     Move SRG to DRG
000029BC  11C0 11C2               2016          MOVE.B  D0,(SMD)        Move DMD to SMD
000029C0  11C1 11C3               2017          MOVE.B  D1,(SRG)        Move DRG to SRG
000029C4  4C9F 0003               2018          MOVEM.W (SP)+,D0/D1     Restore D0 and D1
000029C8  4E75                    2019          RTS                     Return to caller
000029CA                          2020  
000029CA                          2021  * ----------------
000029CA                          2022  * OP Mode Branches
000029CA                          2023  * ----------------
000029CA                          2024  * A1 reserved for tentative good buffer
000029CA                          2025  
000029CA                          2026  
000029CA                          2027  * ARITHMETIC Q Instruction: XXXX|DAT|X|SZ|EMD|ERG
000029CA                          2028  * Syntax: XXXQ      #<1-8>,<ea>
000029CA                          2029  
000029CA  3011                    2030  BRARMQ  MOVE.W  (A1),D0         Move instruction to D0
000029CC  243C 000000C0           2031          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
000029D2  6100 EE6A               2032          BSR     EXTMSK          Get the size to D1
000029D6                          2033  
000029D6  B23C 0003               2034          CMP.B   #%11,D1         Compare size to 11
000029DA  6700 ECF8               2035          BEQ     FLAGCL          If ==, it is invalid, branch to clear flag      
000029DE  11C1 10AA               2036          MOVE.B  D1,(IOSIZE)     Else, store size in IOSIZE
000029E2                          2037  
000029E2                          2038          * dest EA field: "Only alterable addressing modes can be used [...]."
000029E2  303C 01FF               2039          MOVE.W  #M_EAALT,D0     Set EA alterable modes as valid (0000000011111111)
000029E6  618E                    2040          BSR     EXSRC           Extract destination from source location
000029E8  6100 FDC2               2041          BSR     TSTAM           Test modes for validity
000029EC  6600 ECE6               2042          BNE     FLAGCL          If not valid, return unsuccessful
000029F0  6100 FDE2               2043          BSR     ADVBFR          Advance the buffer accordingly
000029F4                          2044          * manually set the source mode and source register
000029F4  11FC 0008 11C0          2045          MOVE.B  #8,(DMD)        Set source mode to  Memory Snipers CUSTOM
000029FA  11FC 0000 11C1          2046          MOVE.B  #0,(DRG)        Set reg mode to 0 for #<1-8>
00002A00  61A2                    2047          BSR     SWAPF           Swap the source and destination values
00002A02  6000 ECCA               2048          BRA     FLAGST          Return successful
00002A06                          2049  
00002A06                          2050  * IMMEDIATE Instruction: XXXXXXXX|SZ|EMD|ERG
00002A06                          2051  * Syntax: XXXX      #<data>,<ea>
00002A06  3011                    2052  BRIMM   MOVE.W  (A1),D0         Move instruction to D0
00002A08  243C 000000C0           2053          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
00002A0E  6100 EE2E               2054          BSR     EXTMSK          Get the size to D1
00002A12                          2055  
00002A12  B23C 0003               2056          CMP.B   #%11,D1         Compare size to 11
00002A16  6700 ECBC               2057          BEQ     FLAGCL          If ==, it is not an immediate instruction, branch to clear flag      
00002A1A  11C1 10AA               2058          MOVE.B  D1,(IOSIZE)     Else, store size in IOSIZE
00002A1E                          2059  
00002A1E                          2060          * dest EA field: "Only data alterable addressing modes can be used [...]."
00002A1E  303C 01FD               2061          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002A22  6100 FF52               2062          BSR     EXSRC           Extract destination from source location
00002A26  6100 FF7C               2063          BSR     SWAPF           Swap the source to dest values
00002A2A  6100 FD80               2064          BSR     TSTAM           Test modes for validity
00002A2E  6600 0028               2065          BNE     BRIMCCR         If not valid, check if mode was CCR
00002A32  6100 FDA0               2066          BSR     ADVBFR          Else, advance the buffer accordingly
00002A36                          2067          * manually set the source mode and source register
00002A36  11FC 0007 11C2          2068          MOVE.B  #$07,(SMD)      Set source mode to 111
00002A3C  11FC 0004 11C3          2069          MOVE.B  #$04,(SRG)      Set reg mode to 100 for immediate data
00002A42  1238 11C3               2070          MOVE.B  (SRG),D1        Copy SRG to D1 to manipulate
00002A46  E709                    2071          LSL.B   #3,D1           Shift the reg 3 bits left
00002A48  8238 11C2               2072          OR.B    (SMD),D1        Add mode after reg 
00002A4C  11C1 11C4               2073          MOVE.B  D1,(RGMD)       Store D1 in RGMD
00002A50  6100 FD82               2074          BSR     ADVBFR          Advance the buffer accordingly
00002A54  6000 EC78               2075          BRA     FLAGST          Return successful
00002A58                          2076  
00002A58  B23C 000B               2077  BRIMCCR CMP.B   #$0B,D1         Compare mode to #<data>
00002A5C  6600 EC76               2078          BNE     FLAGCL          If not valid, branch to FLAGCL
00002A60  11FC 0005 11C1          2079          MOVE.B  #5,(DRG)        Else, set mode to CCR
00002A66  11FC 000A 11C2          2080          MOVE.B  #$A,(SMD)       Set source mode to  Memory Snipers CUSTOM next word
00002A6C  11FC 0001 11C3          2081          MOVE.B  #1,(SRG)        Set reg mode to 1 for #<data>.Q
00002A72  5489                    2082          ADD.L   #2,A1           Advance buffer by word
00002A74  6000 EC58               2083          BRA     FLAGST          Return successful
00002A78                          2084  
00002A78                          2085  * ORI: 0000|0000|SZ|EMD|ERG
00002A78                          2086  * Syntax: ORI       #<data>,<ea>
00002A78                          2087  
00002A78  11FC 003F 10A8          2088  BRORI   MOVE.B  #$3F,(IOOPCD)   Set OP-code name
00002A7E  6086                    2089          BRA     BRIMM           Branch to immediate instruction
00002A80                          2090  
00002A80                          2091  * ANDI: 0000|0010|SZ|EMD|ERG
00002A80                          2092  * Syntax: ANDI      #<data>,<ea> 
00002A80                          2093  
00002A80  11FC 00CF 10A8          2094  BRANDI  MOVE.B  #$CF,(IOOPCD)   Set OP-code name
00002A86  6000 FF7E               2095          BRA     BRIMM           Branch to immediate instruction
00002A8A                          2096  
00002A8A                          2097  * SUBI: 0000|0100|SZ|EMD|ERG
00002A8A                          2098  * Syntax: SUBI      #<data>,<ea> 
00002A8A                          2099  
00002A8A  11FC 0028 10A8          2100  BRSUBI  MOVE.B  #$28,(IOOPCD)   Set OP-code name
00002A90  6000 FF74               2101          BRA     BRIMM           Branch to immediate instruction
00002A94                          2102  
00002A94                          2103  * ADDI: 0000|0110|SZ|EMD|ERG
00002A94                          2104  * Syntax: ADDI      #<data>,<ea>
00002A94                          2105  
00002A94  11FC 009A 10A8          2106  BRADDI  MOVE.B  #$9A,(IOOPCD)   Set OP-code name
00002A9A  6000 FF6A               2107          BRA     BRIMM           Branch to immediate instruction
00002A9E                          2108  
00002A9E                          2109  * EORI: 0000|1010|SZ|EMD|ERG
00002A9E                          2110  * Syntax: EORI      #<data>,<ea>
00002A9E                          2111  
00002A9E  11FC 0047 10A8          2112  BREORI  MOVE.B  #$47,(IOOPCD)   Set OP-code name
00002AA4  6000 FF60               2113          BRA     BRIMM           Branch to immediate instruction
00002AA8                          2114  
00002AA8                          2115  * CMPI: 0000|1100|SZ|EMD|ERG
00002AA8                          2116  * Syntax: CMPI      #<data>,<ea>
00002AA8                          2117  
00002AA8  11FC 0066 10A8          2118  BRCMPI  MOVE.B  #$66,(IOOPCD)   Set OP-code name
00002AAE  6000 FF56               2119          BRA     BRIMM           Branch to immediate instruction
00002AB2                          2120  
00002AB2                          2121  * ADD: 1101|REG|OPM|EMD|ERG
00002AB2                          2122  * Syntax: ADD       <ea>,Dn
00002AB2                          2123  *         ADD       Dn,<ea>
00002AB2                          2124  * Note: The Dn mode is used when the destination is a data register;
00002AB2                          2125  *       the destination <ea> mode is invalid for a data register. 
00002AB2                          2126  *       ADDA is used when the destination is an address register.
00002AB2                          2127  *       ADDI and ADDQ are used when the source is immediate data.
00002AB2                          2128  *       Most assemblers automatically make this distinction.  
00002AB2                          2129  
00002AB2  11FC 0011 10A8          2130  BRADD   MOVE.B  #$11,(IOOPCD)   Set OP-code name
00002AB8  6100 FE86               2131          BSR     EXDST           Extract OP mode & register
00002ABC  6100 FDA8               2132          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
00002AC0                          2133          * "If the location specified is a source operand,
00002AC0                          2134          * all addressing modes can be used [...]."
00002AC0  B43C 0000               2135          CMP.B   #0,D2           Compare operation to Dn
00002AC4  6604                    2136          BNE.S   *+6             If !=, skip next line
00002AC6  303C 0FFF               2137          MOVE.W  #M_ALL,D0       Set all modes as valid
00002ACA                          2138          * "If the location specified is a destination operand,
00002ACA                          2139          * only memory alterable addressing modes can be used [...]."
00002ACA  B43C 0001               2140          CMP.B   #1,D2           Compare operation to <ea>
00002ACE  6604                    2141          BNE.S   *+6             If !=, skip next line
00002AD0  303C 01FC               2142          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00002AD4                          2143          * "ADDA is used when the destination is an address register."
00002AD4  B43C 0002               2144          CMP.B   #2,D2           Compare operation to An
00002AD8  6700 0024               2145          BEQ     BRADDA          If ==, branch to BRADDA
00002ADC  6100 FCF6               2146          BSR     ADVBFR          Else, advance the buffer accordingly
00002AE0  6100 FE94               2147          BSR     EXSRC           Extract EA mode & register
00002AE4  6100 FCC6               2148          BSR     TSTAM           Test modes for validity
00002AE8  6600 EBEA               2149          BNE     FLAGCL          If not valid, return unsuccessful
00002AEC  6100 FCE6               2150          BSR     ADVBFR          Else, advance the buffer accordingly
00002AF0  B43C 0001               2151          CMP.B   #1,D2           Compare operation to <ea>
00002AF4  6604                    2152          BNE     *+6             If !=, skip the next line
00002AF6  6100 FEAC               2153          BSR     SWAPF           Else, swap the destination & source values
00002AFA  6000 EBD2               2154          BRA     FLAGST          Return successful
00002AFE                          2155  
00002AFE                          2156  
00002AFE                          2157  * ADDA: 1101|REG|OPM|EMD|ERG
00002AFE                          2158  * Syntax: ADDA      <ea>,An
00002AFE                          2159  
00002AFE  11FC 0015 10A8          2160  BRADDA  MOVE.B  #$15,(IOOPCD)   Set OP-code name
00002B04  0C38 0000 10AA          2161          CMP.B   #0,(IOSIZE)     Compare size to byte
00002B0A  6700 EBC8               2162          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
00002B0E  6100 FCC4               2163          BSR     ADVBFR          Else, advance the buffer accordingly
00002B12  6100 FE62               2164          BSR     EXSRC           Extract source EA mode & register
00002B16                          2165          * Source EA field: "All addressing modes can be used [...]."
00002B16  303C 0FFF               2166          MOVE.W  #M_ALL,D0       Set all modes as valid (0000011111111111)
00002B1A  6100 FC90               2167          BSR     TSTAM           Test modes for validity
00002B1E  6600 EBB4               2168          BNE     FLAGCL          If not valid, return unsuccessful
00002B22  6100 FCB0               2169          BSR     ADVBFR          Advance the buffer accordingly
00002B26  6000 EBA6               2170          BRA     FLAGST          Return successful
00002B2A                          2171  
00002B2A                          2172  * ADDQ: 0101|DAT|0|SZ|EMD|ERG
00002B2A                          2173  * Syntax: ADDQ      #<1-8>,<ea>
00002B2A                          2174  
00002B2A  11FC 001A 10A8          2175  BRADDQ  MOVE.B  #$1A,(IOOPCD)   Set OP-code name
00002B30  6000 FE98               2176          BRA     BRARMQ          Branch to arithmetic Q instruction
00002B34                          2177  
00002B34                          2178  * SUB: 1001|REG|OPM|EMD|ERG
00002B34                          2179  * Syntax: SUB       <ea>,Dn
00002B34                          2180  *         SUB       Dn,<ea>
00002B34                          2181  * Note: Most assemblers use SUBA when the destination is an address register
00002B34                          2182  *       and SUBI or SUBQ when the source is immediate data.
00002B34                          2183  
00002B34  11FC 001F 10A8          2184  BRSUB   MOVE.B  #$1F,(IOOPCD)   Set OP-code name
00002B3A  6100 FE04               2185          BSR     EXDST           Extract OP mode & register
00002B3E  6100 FD26               2186          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
00002B42                          2187          * "If the location specified is a source operand,
00002B42                          2188          * all addressing modes can be used [...]."
00002B42  B43C 0000               2189          CMP.B   #0,D2           Compare operation to Dn
00002B46  6604                    2190          BNE.S   *+6             If !=, skip next line
00002B48  303C 0FFF               2191          MOVE.W  #M_ALL,D0       Set all modes as valid
00002B4C                          2192          * "If the location specified is a destination operand,
00002B4C                          2193          * only memory alterable addressing modes can be used [...]."
00002B4C  B43C 0001               2194          CMP.B   #1,D2           Compare operation to <ea>
00002B50  6604                    2195          BNE.S   *+6             If !=, skip next line
00002B52  303C 01FC               2196          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00002B56                          2197          * "SUBA is used when the destination is an address register."
00002B56  B43C 0002               2198          CMP.B   #2,D2           Compare operation to An
00002B5A  6700 0024               2199          BEQ     BRSUBA          If ==, branch to BRADDA
00002B5E  6100 FC74               2200          BSR     ADVBFR          Else, advance the buffer accordingly
00002B62  6100 FE12               2201          BSR     EXSRC           Extract EA mode & register
00002B66  6100 FC44               2202          BSR     TSTAM           Test modes for validity
00002B6A  6600 EB68               2203          BNE     FLAGCL          If not valid, return unsuccessful
00002B6E  6100 FC64               2204          BSR     ADVBFR          Else, advance the buffer accordingly
00002B72  B43C 0001               2205          CMP.B   #1,D2           Compare operation to <ea>
00002B76  6604                    2206          BNE     *+6             If !=, skip the next line
00002B78  6100 FE2A               2207          BSR     SWAPF           Else, swap the destination & source values
00002B7C  6000 EB50               2208          BRA     FLAGST          Return successful
00002B80                          2209  
00002B80                          2210  
00002B80                          2211  * SUBA: 1001|REG|OPM|EMD|ERG
00002B80                          2212  * Syntax: SUBA      <ea>,An
00002B80                          2213  
00002B80  11FC 0023 10A8          2214  BRSUBA  MOVE.B  #$23,(IOOPCD)   Set OP-code name
00002B86  0C38 0000 10AA          2215          CMP.B   #0,(IOSIZE)     Compare size to byte
00002B8C  6700 EB46               2216          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
00002B90  6100 FC42               2217          BSR     ADVBFR          Else, advance the buffer accordingly
00002B94                          2218          * "All addressing modes can be used [...]."
00002B94  303C 0FFF               2219          MOVE.W  #M_ALL,D0       Set all modes as valid
00002B98  6100 FDDC               2220          BSR     EXSRC           Extract EA mode & register
00002B9C  6100 FC0E               2221          BSR     TSTAM           Test modes for validity
00002BA0  6600 EB32               2222          BNE     FLAGCL          If not valid, return unsuccessful
00002BA4  6100 FC2E               2223          BSR     ADVBFR          Else, advance the buffer accordingly
00002BA8  6000 EB24               2224          BRA     FLAGST          Return successful
00002BAC                          2225  
00002BAC                          2226  * SUBQ: 0101|DAT|1|SZ|EMD|ERG
00002BAC                          2227  * Syntax: SUBQ      #<1-8>,<ea>
00002BAC  11FC 00D4 10A8          2228  BRSUBQ  MOVE.B  #$D4,(IOOPCD)   Set OP-code name
00002BB2  6000 FE16               2229          BRA     BRARMQ          Branch to arithmetic Q instruction
00002BB6                          2230  
00002BB6                          2231  * AND: 1100|REG|OPM|EMD|ERG
00002BB6                          2232  * Syntax: AND       <ea>,Dn
00002BB6                          2233  *         AND       Dn,<ea>
00002BB6                          2234  * Note: The Dn mode is used when the destination is a data register;
00002BB6                          2235  *       the destination < ea > mode is invalid for a data register. 
00002BB6                          2236  *       Most assemblers use ANDI when the source is immediate data.
00002BB6                          2237  
00002BB6  11FC 003B 10A8          2238  BRAND   MOVE.B  #$3B,(IOOPCD)   Set OP-code name
00002BBC  6100 FD82               2239          BSR     EXDST           Extract OP mode & register
00002BC0  6100 FCA4               2240          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
00002BC4  B43C 0002               2241          CMP.B   #2,D2           Compare OP mode to An
00002BC8  6700 EB0A               2242          BEQ     FLAGCL          If ==, mode is not valid, return unsuccessful
00002BCC  6100 FC06               2243          BSR     ADVBFR          Else, advance the buffer accordingly
00002BD0                          2244          * "If the location specified is a source operand,
00002BD0                          2245          * only data addressing modes can be used [...]."
00002BD0  B43C 0000               2246          CMP.B   #0,D2           Compare operation to Dn
00002BD4  6604                    2247          BNE.S   *+6             If !=, skip next line
00002BD6  303C 0FFD               2248          MOVE.W  #M_DAT,D0       Set data modes as valid
00002BDA                          2249          * "If the location specified is a destination operand,
00002BDA                          2250          * only memory alterable addressing modes can be used [...]."
00002BDA  B43C 0001               2251          CMP.B   #1,D2           Compare operation to <ea>
00002BDE  6604                    2252          BNE.S   *+6             If !=, skip next line
00002BE0  303C 01FC               2253          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00002BE4  6100 FD90               2254          BSR     EXSRC           Extract EA mode & register
00002BE8  6100 FBC2               2255          BSR     TSTAM           Test modes for validity
00002BEC  6600 EAE6               2256          BNE     FLAGCL          If not valid, return unsuccessful
00002BF0  6100 FBE2               2257          BSR     ADVBFR          Else, advance the buffer accordingly
00002BF4  B43C 0001               2258          CMP.B   #1,D2           Compare operation to <ea>
00002BF8  6604                    2259          BNE     *+6             If !=, skip the next line
00002BFA  6100 FDA8               2260          BSR     SWAPF           Else, swap the destination & source values
00002BFE  6000 EACE               2261          BRA     FLAGST          Return successful
00002C02                          2262  
00002C02                          2263  * OR: 1000|REG|OPM|EMD|ERG
00002C02                          2264  * Syntax: OR        <ea>,Dn
00002C02                          2265  *         OR        Dn,<ea>
00002C02                          2266  * Note: The Dn mode is used when the destination is a data register;
00002C02                          2267  *       the destination < ea > mode is invalid for a data register. 
00002C02                          2268  *       Most assemblers use ORI when the source is immediate data.
00002C02                          2269  
00002C02  11FC 00F7 10A8          2270  BROR    MOVE.B  #$F7,(IOOPCD)   Set OP-code name
00002C08  6100 FD36               2271          BSR     EXDST           Extract OP mode & register
00002C0C  6100 FC58               2272          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
00002C10  B43C 0002               2273          CMP.B   #2,D2           Compare OP mode to An
00002C14  6700 EABE               2274          BEQ     FLAGCL          If ==, mode is not valid, return unsuccessful
00002C18  6100 FBBA               2275          BSR     ADVBFR          Else, advance the buffer accordingly
00002C1C                          2276          * "If the location specified is a source operand,
00002C1C                          2277          * only data addressing modes can be used [...]."
00002C1C  B43C 0000               2278          CMP.B   #0,D2           Compare operation to Dn
00002C20  6604                    2279          BNE.S   *+6             If !=, skip next line
00002C22  303C 0FFD               2280          MOVE.W  #M_DAT,D0       Set data modes as valid
00002C26                          2281          * "If the location specified is a destination operand,
00002C26                          2282          * only memory alterable addressing modes can be used [...]."
00002C26  B43C 0001               2283          CMP.B   #1,D2           Compare operation to <ea>
00002C2A  6604                    2284          BNE.S   *+6             If !=, skip next line
00002C2C  303C 01FC               2285          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00002C30  6100 FD44               2286          BSR     EXSRC           Extract EA mode & register
00002C34  6100 FB76               2287          BSR     TSTAM           Test modes for validity
00002C38  6600 EA9A               2288          BNE     FLAGCL          If not valid, return unsuccessful
00002C3C  6100 FB96               2289          BSR     ADVBFR          Else, advance the buffer accordingly
00002C40  B43C 0001               2290          CMP.B   #1,D2           Compare operation to <ea>
00002C44  6604                    2291          BNE     *+6             If !=, skip the next line
00002C46  6100 FD5C               2292          BSR     SWAPF           Else, swap the destination & source values
00002C4A  6000 EA82               2293          BRA     FLAGST          Return successful
00002C4E                          2294  
00002C4E                          2295  
00002C4E                          2296  * BTST: 0000XXXX00|EMD|ERG
00002C4E                          2297  * Syntax: BTST      Dn,<ea>
00002C4E                          2298  *         BTST      #<data>,<ea>
00002C4E                          2299  
00002C4E  11FC 0058 10A8          2300  BRBTST  MOVE.B  #$58,(IOOPCD)   Set OP-code name
00002C54  6100 FCEA               2301          BSR     EXDST           Extract bits in destination mode & register location
00002C58  0C38 0000 11C0          2302          CMP.B   #0,(DMD)        Compare the mode to STATIC
00002C5E  6700 0010               2303          BEQ     BRBTSTS         If ==, branch to BTST STATIC
00002C62  0C38 0004 11C0          2304          CMP.B   #4,(DMD)        Compare the mode to DYNAMIC
00002C68  6700 0054               2305          BEQ     BRBTSTD         If ==, branch to BTST DYNAMIC
00002C6C  6000 EA66               2306          BRA     FLAGCL          If neither were found, return unsuccessful
00002C70                          2307  
00002C70                          2308  * BTST STATIC: 0000100000|EMD|ERG
00002C70                          2309  *              00000000|_BITNUM_
00002C70                          2310  * Syntax: BTST      #<data>,<ea>
00002C70                          2311  
00002C70  6100 FD04               2312  BRBTSTS BSR     EXSRC           Extract destination from source location
00002C74                          2313          * "Only data addressing modes can be used [...]."
00002C74                          2314          * M68 Manual oddly does not note that #<data> is invalid
00002C74  303C 07FD               2315          MOVE.W  #$7FD,D0        Set data modes - #<data> as valid %0000111111111101
00002C78  6100 FB32               2316          BSR     TSTAM           Test modes for validity
00002C7C  6600 EA56               2317          BNE     FLAGCL          If not valid, return unsuccessful
00002C80  6100 FD22               2318          BSR     SWAPF           Else, swap source to destination
00002C84  11FC 0000 10AA          2319          MOVE.B  #0,(IOSIZE)     Set size to byte
00002C8A  0C38 0000 11C0          2320          CMP.B   #0,(DMD)        Compare destination to Dn
00002C90  6606                    2321          BNE     *+8             If !=, skip the next line
00002C92  11FC 0002 10AA          2322          MOVE.B  #2,(IOSIZE)     Else, set size to long
00002C98  6100 FB3A               2323          BSR     ADVBFR          Advance buffer accordingly
00002C9C  5489                    2324          ADD.L   #2,A1           Advance buffer for bit num
00002C9E  11FC 0008 11C2          2325          MOVE.B  #8,(SMD)        Set source mode to  Memory Snipers CUSTOM
00002CA4  11FC 0008 11C3          2326          MOVE.B  #8,(SRG)        Set reg mode to 8 for #<bit num>.B
00002CAA  0C38 0007 11C0          2327          CMP.B   #%111,(DMD)     Compare destination mode to special
00002CB0  6600 EA1C               2328          BNE     FLAGST          If !=, return successful
00002CB4  11FC 0009 11C0          2329          MOVE.B  #%1001,(DMD)    Else if ==, set mode to special-- next word
00002CBA  6000 EA12               2330          BRA     FLAGST          Return successful
00002CBE                          2331  
00002CBE                          2332  * BTST DYNAMIC: 0000|REG|100|EMD|ERG
00002CBE                          2333  * Syntax: BTST      Dn,<ea>
00002CBE                          2334  
00002CBE  6100 FCB6               2335  BRBTSTD BSR     EXSRC           Extract destination from source location
00002CC2                          2336          * "Only data addressing modes can be used [...]."
00002CC2  303C 0FFD               2337          MOVE.W  #M_DAT,D0       Set data modes as valid
00002CC6  6100 FAE4               2338          BSR     TSTAM           Test modes for validity
00002CCA  6600 EA08               2339          BNE     FLAGCL          If not valid, return unsuccessful
00002CCE  6100 FCD4               2340          BSR     SWAPF           Else, swap source to destination
00002CD2  11FC 0000 10AA          2341          MOVE.B  #0,(IOSIZE)     Set size to byte
00002CD8  0C38 0000 11C0          2342          CMP.B   #0,(DMD)        Compare destination to Dn
00002CDE  6606                    2343          BNE     *+8             If !=, skip the next line
00002CE0  11FC 0002 10AA          2344          MOVE.B  #2,(IOSIZE)     Else, set size to long
00002CE6  6100 FAEC               2345          BSR     ADVBFR          Advance buffer accordingly
00002CEA  11FC 0000 11C2          2346          MOVE.B  #0,(SMD)        Set source mode to Dn
00002CF0  6000 E9DC               2347          BRA     FLAGST          Return successful
00002CF4                          2348  
00002CF4                          2349  * Bcc: 0110|COND|_8BTDSP_
00002CF4                          2350  * Syntax: Bcc       <label>
00002CF4                          2351  * Branch on...
00002CF4                          2352  *  BRA:     0000
00002CF4                          2353  *  BSR:     0001
00002CF4                          2354  *   HI:     0010
00002CF4                          2355  *   LS:     0011
00002CF4                          2356  *   CC(HI): 0100
00002CF4                          2357  *   CS(LO): 0101
00002CF4                          2358  *   NE:     0110
00002CF4                          2359  *   EQ:     0111
00002CF4                          2360  *   VC:     1000
00002CF4                          2361  *   VS:     1001
00002CF4                          2362  *   PL:     1010
00002CF4                          2363  *   MI:     1011
00002CF4                          2364  *   GE:     1100
00002CF4                          2365  *   LT:     1101
00002CF4                          2366  *   GT:     1110
00002CF4                          2367  *   LE:     1111
00002CF4                          2368  
00002CF4  11FC 006B 10A8          2369  BRBccd  MOVE.B  #$6B,(IOOPCD)   Set OP-code name
00002CFA  3011                    2370          MOVE.W  (A1),D0         Move instruction to D0
00002CFC  243C 000000FF           2371          MOVE.L  #$00FF,D2       Extract displacement at 0000000011111111
00002D02  6100 EB3A               2372          BSR     EXTMSK          Get the displacement to D1
00002D06  11FC 0008 11C0          2373          MOVE.B  #8,(DMD)        Set mode to  Memory Snipers CUSTOM
00002D0C  11FC 0002 11C1          2374          MOVE.B  #2,(DRG)        Set register to (DISP).Q
00002D12  B23C 0000               2375          CMP.B   #$00,D1         $00 = 16 bit displacement
00002D16  6608                    2376          BNE.S   *+10            If !=, skip next two lines
00002D18  11FC 0004 11C1          2377          MOVE.B  #4,(DRG)        Else, Set register to (DISP).W
00002D1E  5489                    2378          ADD.L   #2,A1           Advance buffer by word
00002D20  B23C 00FF               2379          CMP.B   #$FF,D1         $FF = 32 bit displacement
00002D24  6608                    2380          BNE.S   *+10            If !=, skip next two lines
00002D26  11FC 0005 11C1          2381          MOVE.B  #5,(DRG)        Else, Set register to (DISP).L
00002D2C  5889                    2382          ADD.L   #4,A1           Advance buffer by long
00002D2E  243C 00000F00           2383          MOVE.L  #$0F00,D2       Extract condition at  0000111100000000
00002D34  4281                    2384          CLR.L   D1              Clear D1 for table displacement
00002D36  6100 EB06               2385          BSR     EXTMSK          Get the condition to D1
00002D3A  C2FC 0004               2386          MULU.W  #4,D1           Convert condition to displacement
00002D3E  4EFB 1002               2387          JMP     BccTBL(PC,D1)   Jump to condition code branch
00002D42  6000 006A               2388  BccTBL  BRA     BRBRA
00002D46  6000 0070               2389          BRA     BRBSR
00002D4A  6000 0058               2390          BRA     BRBHI
00002D4E  6000 00CC               2391          BRA     BRBLS
00002D52  6000 006E               2392          BRA     BRBCC
00002D56  6000 0074               2393          BRA     BRBCS
00002D5A  6000 003E               2394          BRA     BRBNE
00002D5E  6000 0026               2395          BRA     BRBEQ
00002D62  6000 0072               2396          BRA     BRBVC
00002D66  6000 0078               2397          BRA     BRBVS
00002D6A  6000 007E               2398          BRA     BRBPL
00002D6E  6000 0084               2399          BRA     BRBMI
00002D72  6000 008A               2400          BRA     BRBGE
00002D76  6000 0018               2401          BRA     BRBLT
00002D7A  6000 008C               2402          BRA     BRBGT
00002D7E  6000 0092               2403          BRA     BRBLE
00002D82  6000 E950               2404          BRA     FLAGCL          Return unsuccessful-- this should never happen
00002D86                          2405  
00002D86  11FC 006F 10A8          2406  BRBEQ   MOVE.B  #$6F,(IOOPCD)   Set OP-code name
00002D8C  6000 E940               2407          BRA     FLAGST          Return successful
00002D90                          2408          
00002D90  11FC 0073 10A8          2409  BRBLT   MOVE.B  #$73,(IOOPCD)   Set OP-code name
00002D96  6000 E936               2410          BRA     FLAGST          Return successful
00002D9A                          2411  
00002D9A  11FC 0077 10A8          2412  BRBNE   MOVE.B  #$77,(IOOPCD)   Set OP-code name
00002DA0  6000 E92C               2413          BRA     FLAGST          Return successful
00002DA4                          2414  
00002DA4  11FC 007B 10A8          2415  BRBHI   MOVE.B  #$7B,(IOOPCD)   Set OP-code name
00002DAA  6000 E922               2416          BRA     FLAGST          Return successful
00002DAE                          2417  
00002DAE  11FC 009F 10A8          2418  BRBRA   MOVE.B  #$9F,(IOOPCD)   Set OP-code name
00002DB4  6000 E918               2419          BRA     FLAGST          Return successful
00002DB8                          2420          
00002DB8  11FC 00A3 10A8          2421  BRBSR   MOVE.B  #$A3,(IOOPCD)   Set OP-code name
00002DBE  6000 E90E               2422          BRA     FLAGST          Return successful
00002DC2                          2423  
00002DC2  11FC 00A7 10A8          2424  BRBCC   MOVE.B  #$A7,(IOOPCD)   Set OP-code name
00002DC8  6000 E904               2425          BRA     FLAGST          Return successful
00002DCC                          2426  
00002DCC  11FC 00AB 10A8          2427  BRBCS   MOVE.B  #$AB,(IOOPCD)   Set OP-code name
00002DD2  6000 E8FA               2428          BRA     FLAGST          Return successful
00002DD6                          2429  
00002DD6  11FC 00AF 10A8          2430  BRBVC   MOVE.B  #$AF,(IOOPCD)   Set OP-code name
00002DDC  6000 E8F0               2431          BRA     FLAGST          Return successful
00002DE0                          2432  
00002DE0  11FC 00B3 10A8          2433  BRBVS   MOVE.B  #$B3,(IOOPCD)   Set OP-code name
00002DE6  6000 E8E6               2434          BRA     FLAGST          Return successful
00002DEA                          2435          
00002DEA  11FC 00B7 10A8          2436  BRBPL   MOVE.B  #$B7,(IOOPCD)   Set OP-code name
00002DF0  6000 E8DC               2437          BRA     FLAGST          Return successful
00002DF4                          2438  
00002DF4  11FC 00BB 10A8          2439  BRBMI   MOVE.B  #$BB,(IOOPCD)   Set OP-code name
00002DFA  6000 E8D2               2440          BRA     FLAGST          Return successful
00002DFE                          2441  
00002DFE  11FC 00BF 10A8          2442  BRBGE   MOVE.B  #$BF,(IOOPCD)   Set OP-code name
00002E04  6000 E8C8               2443          BRA     FLAGST          Return successful
00002E08                          2444  
00002E08  11FC 00C3 10A8          2445  BRBGT   MOVE.B  #$C3,(IOOPCD)   Set OP-code name
00002E0E  6000 E8BE               2446          BRA     FLAGST          Return successful
00002E12                          2447  
00002E12  11FC 00C7 10A8          2448  BRBLE   MOVE.B  #$C7,(IOOPCD)   Set OP-code name
00002E18  6000 E8B4               2449          BRA     FLAGST          Return successful
00002E1C                          2450  
00002E1C  11FC 00CB 10A8          2451  BRBLS   MOVE.B  #$CB,(IOOPCD)   Set OP-code name
00002E22  6000 E8AA               2452          BRA     FLAGST          Return successful
00002E26                          2453  
00002E26                          2454  * CMP: 1011|REG|OPM|EMD|ERG
00002E26                          2455  * Syntax: CMP       <ea>,Dn
00002E26                          2456  * Note: CMPA is used when the destination is an address register.
00002E26                          2457  *       CMPI is used when the source is immediate data.
00002E26                          2458  *       CMPM is used for memory-to-memory compares.
00002E26                          2459  *       Most assemblers automatically make the distinction.
00002E26                          2460  
00002E26  11FC 005D 10A8          2461  BRCMP   MOVE.B  #$5D,(IOOPCD)   Set OP-code name
00002E2C  6100 FB12               2462          BSR     EXDST           Extract OP mode & register
00002E30  6100 FA34               2463          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
00002E34  B43C 0001               2464          CMP.B   #1,D2           Compare OP mode to <ea>
00002E38  6700 E89A               2465          BEQ     FLAGCL          If ==, it is invalid, branch to flag clear
00002E3C  B43C 0002               2466          CMP.B   #2,D2           Compare OP mode to An
00002E40  6700 001E               2467          BEQ     BRCMPA          If ==, branch to BRCMPA
00002E44  6100 F98E               2468          BSR     ADVBFR          Else, advance the buffer acco\rdingly
00002E48  6100 FB2C               2469          BSR     EXSRC           Extract source mode & register
00002E4C                          2470          * Source EA field: "All addressing modes can be used [...]."
00002E4C  303C 0FFF               2471          MOVE.W  #M_ALL,D0       Set all modes as valid
00002E50  6100 F95A               2472          BSR     TSTAM           Test modes for validity
00002E54  6600 E87E               2473          BNE     FLAGCL          If not valid, return unsuccessful
00002E58  6100 F97A               2474          BSR     ADVBFR          Else, advance the buffer accordingly
00002E5C  6000 E870               2475          BRA     FLAGST          Return successful
00002E60                          2476  
00002E60                          2477  * CMPA: 1011|REG|OPM|EMD|ERG
00002E60                          2478  * Syntax: CMPA      <ea>,An
00002E60                          2479  
00002E60  11FC 0061 10A8          2480  BRCMPA  MOVE.B  #$61,(IOOPCD)   Set OP-code name
00002E66  0C38 0000 10AA          2481          CMP.B   #0,(IOSIZE)     Compare size to byte
00002E6C  6700 E866               2482          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
00002E70  6100 F962               2483          BSR     ADVBFR          Else, advance the buffer accordingly
00002E74  6100 FB00               2484          BSR     EXSRC           Extract source EA mode & register
00002E78                          2485          * Source EA field: "All addressing modes can be used [...]."
00002E78  303C 0FFF               2486          MOVE.W  #M_ALL,D0       Set all modes as valid (0000011111111111)
00002E7C  6100 F92E               2487          BSR     TSTAM           Test modes for validity
00002E80  6600 E852               2488          BNE     FLAGCL          If not valid, return unsuccessful
00002E84  6100 F94E               2489          BSR     ADVBFR          Else, advance the buffer accordingly
00002E88  6000 E844               2490          BRA     FLAGST          Return successful
00002E8C                          2491  
00002E8C                          2492  * EOR: 1011|REG|OPM|EMD|ERG
00002E8C                          2493  * Syntax: EOR       Dn,<ea>
00002E8C                          2494  * Note: Memory-to-data-register operations are not allowed.
00002E8C                          2495  *       Most assemblers use EORI when the source is immediate data.
00002E8C                          2496  
00002E8C  11FC 0043 10A8          2497  BREOR   MOVE.B  #$43,(IOOPCD)   Set OP-code name
00002E92  6100 FAAC               2498          BSR     EXDST           Extract OP mode & register
00002E96  6100 F9CE               2499          BSR     OPSIZE          Translate OP mode from DMD, get operation in D2.B
00002E9A  B43C 0001               2500          CMP.B   #1,D2           Compare OP mode to <ea>
00002E9E  6600 E834               2501          BNE     FLAGCL          If !=, it is invalid, branch to flag clear
00002EA2  6100 F930               2502          BSR     ADVBFR          Else, advance the buffer accordingly
00002EA6  6100 FACE               2503          BSR     EXSRC           Extract source mode & register
00002EAA                          2504          * Source EA field: "Only data alterable modes can be used [...]."
00002EAA  303C 01FD               2505          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002EAE  6100 F8FC               2506          BSR     TSTAM           Test modes for validity
00002EB2  6600 E820               2507          BNE     FLAGCL          If not valid, return unsuccessful
00002EB6  6100 F91C               2508          BSR     ADVBFR          Else, advance the buffer accordingly
00002EBA  6100 FAE8               2509          BSR     SWAPF           Swap dest & source fields
00002EBE  6000 E80E               2510          BRA     FLAGST          Return successful
00002EC2                          2511  
00002EC2                          2512  * LEA: 0100|REG|111|EMD|ERG
00002EC2                          2513  * Syntax: LEA       <ea>,An
00002EC2                          2514  
00002EC2  11FC 0037 10A8          2515  BRLEA   MOVE.B  #$37,(IOOPCD)   Set OP-code name
00002EC8  6100 FA76               2516          BSR     EXDST           Extract destination mode & register
00002ECC  11FC 0001 11C0          2517          MOVE.B  #%001,(DMD)     Set destination mode to An
00002ED2  6100 FAA2               2518          BSR     EXSRC           Extract source mode & register
00002ED6                          2519          * "Source EA field: "Only control addressing modes can be used [...]."
00002ED6  303C 07E4               2520          MOVE.W  #M_CTR,D0       Set control modes as valid
00002EDA  6100 F8D0               2521          BSR     TSTAM           Test modes for validity
00002EDE  6600 E7F4               2522          BNE     FLAGCL          If not valid, return unsuccessful
00002EE2  6100 F8F0               2523          BSR     ADVBFR          Else, advance the buffer accordingly
00002EE6  6000 E7E6               2524          BRA     FLAGST          Return successful
00002EEA                          2525  
00002EEA                          2526  * JSR: 0100111010|EMD|ERG
00002EEA                          2527  * Syntax: JSR       <ea>
00002EEA                          2528  
00002EEA  11FC 007F 10A8          2529  BRJSR   MOVE.B  #$7F,(IOOPCD)   Set OP-code name
00002EF0  6100 FA84               2530          BSR     EXSRC           Extract source mode & register
00002EF4                          2531          * "Source EA field: "Only control addressing modes can be used [...]."
00002EF4  303C 07E4               2532          MOVE.W  #M_CTR,D0       Set control modes as valid
00002EF8  6100 F8B2               2533          BSR     TSTAM           Test modes for validity
00002EFC  6600 E7D6               2534          BNE     FLAGCL          If not valid, return unsuccessful
00002F00  6100 F8D2               2535          BSR     ADVBFR          Else, advance the buffer accordingly
00002F04  6000 E7C8               2536          BRA     FLAGST          Return successful
00002F08                          2537  
00002F08                          2538  * JMP: 0100111011|EMD|ERG
00002F08                          2539  * Syntax: JMP       <ea>
00002F08                          2540  
00002F08  11FC 00D9 10A8          2541  BRJMP   MOVE.B  #$D9,(IOOPCD)   Set OP-code name
00002F0E  6100 FA66               2542          BSR     EXSRC           Extract source mode & register
00002F12                          2543          * "Source EA field: "Only control addressing modes can be used [...]."
00002F12  303C 07E4               2544          MOVE.W  #M_CTR,D0       Set control modes as valid
00002F16  6100 F894               2545          BSR     TSTAM           Test modes for validity
00002F1A  6600 E7B8               2546          BNE     FLAGCL          If not valid, return unsuccessful
00002F1E  6100 F8B4               2547          BSR     ADVBFR          Else, advance the buffer accordingly
00002F22  6000 E7AA               2548          BRA     FLAGST          Return successful
00002F26                          2549          
00002F26                          2550  * MOVE: 00|SZ|DRG|DMD|SMD|SRG
00002F26                          2551  * Syntax: MOVE      <ea>,<ea>
00002F26                          2552  * Note: Most assemblers use MOVEA when the destination is an address register. 
00002F26                          2553  *       MOVEQ can be used to move an immediate 8-bit value to a data register. 
00002F26                          2554  
00002F26  11FC 0000 10A8          2555  BRMOVE  MOVE.B  #$00,(IOOPCD)   Set OP-code name
00002F2C  3011                    2556          MOVE.W  (A1),D0         Move instruction to D0
00002F2E  243C 00003000           2557          MOVE.L  #$3000,D2       Extract size at 0011000000000000
00002F34  6100 E908               2558          BSR     EXTMSK          Get the size to D1
00002F38                          2559  
00002F38  103C 00FF               2560          MOVE.B  #$FF,D0         Set size to null
00002F3C  B23C 0001               2561          CMP.B   #%01,D1         01 = Byte
00002F40  6604                    2562          BNE.S   *+6             Branch to next test
00002F42  103C 0000               2563          MOVE.B  #$0,D0          Set size to byte
00002F46  B23C 0003               2564          CMP.B   #%11,D1         11 = Word
00002F4A  6604                    2565          BNE.S   *+6             Branch to next test
00002F4C  103C 0001               2566          MOVE.B  #$1,D0          Set size to word
00002F50  B23C 0002               2567          CMP.B   #%10,D1         10 = Long
00002F54  6604                    2568          BNE.S   *+6             Branch to next test
00002F56  103C 0002               2569          MOVE.B  #$2,D0          Set size to long
00002F5A  B03C 00FF               2570          CMP.B   #$FF,D0         Test if size was found
00002F5E  6700 E774               2571          BEQ     FLAGCL          If it was not found, branch to clear flag      
00002F62  11C0 10AA               2572          MOVE.B  D0,(IOSIZE)     If it was found, store size in IOSIZE
00002F66                          2573  
00002F66  6100 F9D8               2574          BSR     EXDST           Extract dest EA mode & register
00002F6A  0C38 0001 11C0          2575          CMP.B   #1,(DMD)        Compare mode to An
00002F70  6700 002A               2576          BEQ     BRMOVEA         If ==, branch to BRMOVEA
00002F74                          2577          * Dest EA field: "Only data alterable addressing modes can be used [...]."
00002F74  303C 01FD               2578          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
00002F78  6100 F832               2579          BSR     TSTAM           Test modes for validity
00002F7C  6600 E756               2580          BNE     FLAGCL          If not valid, return unsuccessful
00002F80  6100 F852               2581          BSR     ADVBFR          Else, advance the buffer accordingly
00002F84  6100 F9F0               2582          BSR     EXSRC           Extract source EA mode & register
00002F88                          2583          * Source EA field: "All addressing modes can be used [...]."
00002F88  303C 0FFF               2584          MOVE.W  #M_ALL,D0       Set all modes as valid
00002F8C  6100 F81E               2585          BSR     TSTAM           Test modes for validity
00002F90  6600 E742               2586          BNE     FLAGCL          If not valid, return unsuccessful
00002F94  6100 F83E               2587          BSR     ADVBFR          Else, advance the buffer accordingly
00002F98                          2588  
00002F98  6000 E734               2589          BRA     FLAGST          Return successful
00002F9C                          2590  
00002F9C                          2591  
00002F9C                          2592  * MOVEA: 00|SZ|DRG|001|SMD|SRG
00002F9C                          2593  * Syntax: MOVEA     <ea>,An
00002F9C                          2594  
00002F9C  11FC 0005 10A8          2595  BRMOVEA MOVE.B  #$05,(IOOPCD)   Set Op-code name
00002FA2  0C38 0000 10AA          2596          CMP.B   #0,(IOSIZE)     Compare size to byte
00002FA8  6700 E72A               2597          BEQ     FLAGCL          If ==, size is not valid, return unsuccessful
00002FAC  6100 F826               2598          BSR     ADVBFR          Else, advance the buffer accordingly
00002FB0  6100 F9C4               2599          BSR     EXSRC           Extract source EA mode & register
00002FB4                          2600          * Source EA field: "All addressing modes can be used [...]."
00002FB4  303C 0FFF               2601          MOVE.W  #M_ALL,D0       Set all modes as valid (0000011111111111)
00002FB8  6100 F7F2               2602          BSR     TSTAM           Test modes for validity
00002FBC  6600 E716               2603          BNE     FLAGCL          If not valid, return unsuccessful
00002FC0  6100 F812               2604          BSR     ADVBFR          Else advance the buffer accordingly
00002FC4  6000 E708               2605          BRA     FLAGST          Return successful
00002FC8                          2606  
00002FC8                          2607  * MOVEM: 01001|D|001|S|EMD|ERG  REGISTERLISTMASK
00002FC8                          2608  * Syntax: MOVEM     <list>,<ea>
00002FC8                          2609  *         MOVEM     <ea>,<list>
00002FC8                          2610  
00002FC8  11FC 000B 10A8          2611  BRMOVEM MOVE.B  #$0B,(IOOPCD)   Set OP-code name
00002FCE  3011                    2612          MOVE.W  (A1),D0         Move instruction to D0
00002FD0  7440                    2613          MOVE.L  #$40,D2         Extract size at 0000000001000000
00002FD2  6100 E86A               2614          BSR     EXTMSK          Get the size to D1
00002FD6  5201                    2615          ADD.B   #1,D1           Convert size to W/L
00002FD8  11C1 10AA               2616          MOVE.B  D1,(IOSIZE)     Store D1 in size
00002FDC  243C 00000400           2617          MOVE.L  #$0400,D2       Extract direction at 0000010000000000
00002FE2  6100 E85A               2618          BSR     EXTMSK          Get the direction to D1
00002FE6  1401                    2619          MOVE.B  D1,D2           Move direction to D2
00002FE8                          2620          * Direction 0 = Register-to-memory
00002FE8                          2621          * Direction 1 = Memory-to-register
00002FE8  6100 F98C               2622          BSR     EXSRC           Get the EA mode & reg from source location
00002FEC                          2623          * EA field: "For register-to-memory transfers,
00002FEC                          2624          * only control alterable addressing modes
00002FEC                          2625          * or the predecrement addressing mode can be used [...]."
00002FEC  303C 01F4               2626          MOVE.W  #$1F4,D0        Set valid modes for reg-to-mem by default (0000000111110100)
00002FF0  B43C 0000               2627          CMP.B   #0,D2           Compare direction to reg-to-mem
00002FF4  6704                    2628          BEQ.S   *+6             If ==, skip the next line
00002FF6                          2629          * EA field: "For memory-to-register transfers,
00002FF6                          2630          * only control addressing modes
00002FF6                          2631          * or the postincrement addressing mode can be used [...]."
00002FF6  303C 07EC               2632          MOVE.W  #$7EC,D0        Else, Set valid modes for mem-to-reg (0000011111101100)
00002FFA  6100 F7B0               2633          BSR     TSTAM           Test modes for validity
00002FFE  6600 E6D4               2634          BNE     FLAGCL          If not valid, return unsuccessful
00003002  6100 F7D0               2635          BSR     ADVBFR          Else advance the buffer accordingly, store displacement in EA
00003006  11FC 0008 11C0          2636          MOVE.B  #8,(DMD)        Set mode to  Memory Snipers CUSTOM
0000300C  11FC 0006 11C1          2637          MOVE.B  #6,(DRG)        Set register to (RLM).W by default
00003012                          2638          * "For the predecrement mode addresses, the mask correspondence is reversed."
00003012  0C38 0004 11C2          2639          CMP.B   #%100,(SMD)     Compare source mode to predecrement mode
00003018  6606                    2640          BNE.S   *+8             If !=, skip next line
0000301A  11FC 0007 11C1          2641          MOVE.B  #7,(DRG)        Else if ==, set register to (MLR).W
00003020  0C38 0007 11C2          2642          CMP.B   #7,(SMD)        Compare source mode to special
00003026  6606                    2643          BNE.S   *+8             If !=, skip next line
00003028  11FC 0009 11C2          2644          MOVE.B  #9,(SMD)        Else if ==, set mode to special-- next word
0000302E  5489                    2645          ADD.L   #2,A1           Advance buffer by word for RLM
00003030  6100 F972               2646          BSR     SWAPF           Swap the source and dest values
00003034  B43C 0000               2647          CMP.B   #0,D2           Compare direction to reg-to-mem
00003038  6700 E694               2648          BEQ     FLAGST          If ==, return successful
0000303C  6100 F966               2649          BSR     SWAPF           Else, swap back values
00003040  1038 11C5               2650          MOVE.B  (DIS),D0        Get displacement of EA in D0
00003044  B03C 0000               2651          CMP.B   #0,D0           Compare displacement to 0
00003048  6700 E684               2652          BEQ     FLAGST          If ==, return successful
0000304C  11FC 000B 11C0          2653          MOVE.B  #$B,(DMD)       Else, set mode to 3B special-- previous word
00003052  B03C 0002               2654          CMP.B   #2,D0           Compare displacement to 4
00003056  6700 E676               2655          BEQ     FLAGST          If ==, return successful
0000305A  11FC 000C 11C0          2656          MOVE.B  #$C,(DMD)       Else, set mode to 3B special-- previous long        
00003060  6000 E66C               2657          BRA     FLAGST          Return successful
00003064                          2658  
00003064                          2659  * MOVEQ: 0111|REG|0|__DATA__
00003064                          2660  * Syntax: MOVEQ     #<data>,Dn
00003064                          2661  
00003064  11FC 008C 10A8          2662  BRMOVEQ MOVE.B  #$8C,(IOOPCD)   Set OP-code name
0000306A  6100 F8D4               2663          BSR     EXDST           Extract destination
0000306E  11FC 0000 11C0          2664          MOVE.B  #0,(DMD)        Set destination mode to Dn
00003074  11FC 0008 11C2          2665          MOVE.B  #8,(SMD)        Set source mode to  Memory Snipers CUSTOM
0000307A  11FC 0001 11C3          2666          MOVE.B  #1,(SRG)        Set reg mode to 1 for #<data>.Q
00003080  11FC 0002 10AA          2667          MOVE.B  #2,(IOSIZE)     Set size to long
00003086  6000 E646               2668          BRA     FLAGST          Return successful
0000308A                          2669  
0000308A                          2670  
0000308A                          2671  * ASd: 1110000|d|11|EMD|ERG (memory shifts)
0000308A                          2672  *      1110|CRG|d|SZ|i|00|REG (register shifts)
0000308A                          2673  * Syntax: ASd       Dx,Dy
0000308A                          2674  *         ASd       #<data>,Dy
0000308A                          2675  *         ASd       <ea>
0000308A                          2676  
0000308A  3011                    2677  BRASd   MOVE.W  (A1),D0         Move instruction to D0
0000308C                          2678  
0000308C  11FC 0096 10A8          2679          MOVE.B  #$96,(IOOPCD)   Set OP-code name to ASR
00003092  7408                    2680          MOVE.L  #$8,D2          Extract direction at 0000000100000000
00003094  6100 E7A8               2681          BSR     EXTMSK          Get the direction to D1
00003098  B23C 0000               2682          CMP.B   #0,D1           Compare direction to 0
0000309C  6606                    2683          BNE     *+8             If ==, skip the next line
0000309E  11FC 0050 10A8          2684          MOVE.B  #$50,(IOOPCD)   Else, set OP-code name to ASL
000030A4                          2685  
000030A4  243C 000000C0           2686          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
000030AA  6100 E792               2687          BSR     EXTMSK          Get the size to D1
000030AE  B23C 0003               2688          CMP.B   #%11,D1         Compare size to 11
000030B2  6700 009A               2689          BEQ     BRMSd           If ==, branch to memory shift
000030B6  6000 0032               2690          BRA     BRRSd           Else, branch to register shift
000030BA                          2691  
000030BA                          2692  * LSd: 1110001|d|11|EMD|ERG (memory shifts)
000030BA                          2693  *      1110|CRG|d|SZ|i|01|REG (register shifts)
000030BA                          2694  * Syntax: LSd       Dx,Dy
000030BA                          2695  *         LSd       #<data>,Dy
000030BA                          2696  *         LSd       <ea>
000030BA                          2697  
000030BA  3011                    2698  BRLSd   MOVE.W  (A1),D0         Move instruction to D0
000030BC                          2699  
000030BC  11FC 0054 10A8          2700          MOVE.B  #$54,(IOOPCD)   Set OP-code name to LSR
000030C2  7408                    2701          MOVE.L  #$8,D2          Extract direction at 0000000100000000
000030C4  6100 E778               2702          BSR     EXTMSK          Get the direction to D1
000030C8  B23C 0000               2703          CMP.B   #0,D1           Compare direction to 0
000030CC  6606                    2704          BNE     *+8             If ==, skip the next line
000030CE  11FC 0092 10A8          2705          MOVE.B  #$92,(IOOPCD)   Else, set OP-code name to LSL
000030D4                          2706  
000030D4  243C 000000C0           2707          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
000030DA  6100 E762               2708          BSR     EXTMSK          Get the size to D1
000030DE  B23C 0003               2709          CMP.B   #%11,D1         Compare size to 11
000030E2  6700 006A               2710          BEQ     BRMSd           If ==, branch to memory shift
000030E6  6000 0002               2711          BRA     BRRSd           Else, branch to register shift
000030EA                          2712  
000030EA                          2713  * RSd: 1110|CRG|d|SZ|i|01|REG
000030EA                          2714  * Syntax: RSd       Dx,Dy
000030EA                          2715  *         RSd       #<data>,Dy
000030EA                          2716  
000030EA  B23C 0000               2717  BRRSd   CMP.B   #%00,D1         01 = Byte
000030EE  6604                    2718          BNE.S   *+6             If !=, branch to next line
000030F0  143C 0000               2719          MOVE.B  #$0,D2          Else, set size to byte
000030F4  B23C 0001               2720          CMP.B   #%01,D1         11 = Word
000030F8  6604                    2721          BNE.S   *+6             If !=, branch to next line
000030FA  143C 0001               2722          MOVE.B  #$1,D2          Else, set size to word
000030FE  B23C 0002               2723          CMP.B   #%10,D1         10 = Long
00003102  6604                    2724          BNE.S   *+6             If !=, Branch to next line
00003104  143C 0002               2725          MOVE.B  #$2,D2          Else, set size to long
00003108  11C2 10AA               2726          MOVE.B  D2,(IOSIZE)     Move size to IOSIZE
0000310C  7407                    2727          MOVE.L  #$0007,D2       Extract register at 0000000000000111
0000310E  6100 E72E               2728          BSR     EXTMSK          Get the reg to D1
00003112  11C1 11C1               2729          MOVE.B  D1,(DRG)        Store the reg in the destination register
00003116  11FC 0000 11C0          2730          MOVE.B  #$0,(DMD)       Set the destination mode to Dn
0000311C  11FC 0008 11C2          2731          MOVE.B  #8,(SMD)        Set source mode to  Memory Snipers CUSTOM
00003122  11FC 0000 11C3          2732          MOVE.B  #0,(SRG)        Set reg mode to 0 for #<1-8>
00003128  7420                    2733          MOVE.L  #$0020,D2       Extract i/r at 0000000000100000
0000312A  6100 E712               2734          BSR     EXTMSK          Get the i/r to D1
0000312E  B23C 0000               2735          CMP.B   #0,D1           Compare i/r to 0
00003132  6700 E59A               2736          BEQ     FLAGST          If ==, branch to set flag
00003136  243C 00000E00           2737          MOVE.L  #$0E00,D2       Else, extract reg at 0000111000000000
0000313C  6100 E700               2738          BSR     EXTMSK          Get the reg to D1
00003140  11C1 11C3               2739          MOVE.B  D1,(SRG)        Store the reg in the source register
00003144  11FC 0000 11C2          2740          MOVE.B  #0,(SMD)        Set source mode to Dn
0000314A  6000 E582               2741          BRA     FLAGST          Branch to flag set
0000314E                          2742  
0000314E                          2743  * MSd: 111000X|d|11|EMD|ERG
0000314E                          2744  * Syntax: MSd       <ea>
0000314E                          2745  
0000314E  11FC 0001 10AA          2746  BRMSd   MOVE.B  #$1,(IOSIZE)    Set size to word
00003154                          2747          * EA field: "Only memory alterable addressing modes can be used [...]."
00003154  303C 01FC               2748          MOVE.W  #M_MALT,D0      Set memory alterable modes as valid
00003158  6100 F81C               2749          BSR     EXSRC           Extract destination from source location
0000315C  6100 F846               2750          BSR     SWAPF           Swap destination and source values
00003160  6100 F64A               2751          BSR     TSTAM           Test modes for validity
00003164  6600 E56E               2752          BNE     FLAGCL          If invalid, return unsuccessful
00003168  6100 F66A               2753          BSR     ADVBFR          Else, advance the buffer accordingly
0000316C  6000 E560               2754          BRA     FLAGST          Branch to set flag
00003170                          2755  
00003170                          2756  * MULU: 1100|REG|011|EMD|ERG
00003170                          2757  * Syntax: MULU.W    <ea>,Dn    16x16 -> 32
00003170                          2758  
00003170  11FC 002D 10A8          2759  BRMULU  MOVE.B  #$2D,(IOOPCD)   Set OP-code name
00003176  3011                    2760          MOVE.W  (A1),D0         Move instruction to D0
00003178  6100 F7C6               2761          BSR     EXDST           Extract values in destination location
0000317C  6000 0032               2762          BRA     BRARW           Branch to arithmetic word instruction
00003180                          2763  
00003180                          2764  * MULS: 1100|REG|111|EMD|ERG
00003180                          2765  * Syntax: MULS.W    <ea>,Dn    16x16 -> 32
00003180                          2766  
00003180  11FC 00ED 10A8          2767  BRMULS  MOVE.B  #$ED,(IOOPCD)   Set OP-code name
00003186  3011                    2768          MOVE.W  (A1),D0         Move instruction to D0
00003188  6100 F7B6               2769          BSR     EXDST           Extract values in destination location
0000318C  6000 0022               2770          BRA     BRARW           Branch to arithmetic word instruction
00003190                          2771  
00003190                          2772  * DIVU: 1000|REG|011|EMD|ERG
00003190                          2773  * Synax: DIVU.W     <ea>,Dn     32/16 -> 16r-16q
00003190                          2774  
00003190  11FC 00F2 10A8          2775  BRDIVU  MOVE.B  #$F2,(IOOPCD)   Set OP-code name     
00003196  3011                    2776          MOVE.W  (A1),D0         Move instruction to D0
00003198  6100 F7A6               2777          BSR     EXDST           Extract values in destination location
0000319C  6000 0012               2778          BRA     BRARW           Branch to arithmetic word instruction
000031A0                          2779  
000031A0                          2780  * DIVS: 1000|REG|111|EMD|ERG
000031A0                          2781  * Synax: DIVS.W     <ea>,Dn     32/16 -> 16r-16q
000031A0                          2782  
000031A0  11FC 0032 10A8          2783  BRDIVS  MOVE.B  #$32,(IOOPCD)   Set OP-code name     
000031A6  3011                    2784          MOVE.W  (A1),D0         Move instruction to D0
000031A8  6100 F796               2785          BSR     EXDST           Extract values in destination location
000031AC  6000 0002               2786          BRA     BRARW           Branch to arithmetic word instruction
000031B0                          2787  
000031B0                          2788  * ARW: XX00|REG|X11|EMD|ERG
000031B0                          2789  * Syntax: ARW       <ea>,Dn    16x16 -> 32
000031B0                          2790  
000031B0  11FC 0001 10AA          2791  BRARW   MOVE.B  #$1,(IOSIZE)    Set size to word
000031B6  11FC 0000 11C0          2792          MOVE.B  #$0,(DMD)       Set destination mode to Dn
000031BC                          2793          * EA field: "Only data addressing modes can be used [...]."
000031BC  303C 0FFD               2794          MOVE.W  #M_DAT,D0       Set data modes as valid
000031C0  6100 F7B4               2795          BSR     EXSRC           Extract source
000031C4  6100 F5E6               2796          BSR     TSTAM           Test modes for validity
000031C8  6600 E50A               2797          BNE     FLAGCL          If invalid, return unsuccessful
000031CC  6100 F606               2798          BSR     ADVBFR          Else, advance the buffer accordingly
000031D0  6000 E4FC               2799          BRA     FLAGST          Branch to set flag
000031D4                          2800  
000031D4                          2801   
000031D4                          2802  * NOT: 01000110|SZ|EMD|ERG
000031D4                          2803  * Syntax:  NOT      <ea>
000031D4                          2804  
000031D4  11FC 004C 10A8          2805  BRNOT   MOVE.B  #$4C,(IOOPCD)   Set OP-code name
000031DA  3011                    2806          MOVE.W  (A1),D0         Move instruction to D0
000031DC  243C 000000C0           2807          MOVE.L  #$00C0,D2       Extract size at 0000000011000000
000031E2  6100 E65A               2808          BSR     EXTMSK          Get the size to D1
000031E6                          2809  
000031E6  B23C 0003               2810          CMP.B   #%11,D1         Compare size to 11
000031EA  6700 E4E8               2811          BEQ     FLAGCL          If ==, it is not NOT, branch to clear flag      
000031EE  11C1 10AA               2812          MOVE.B  D1,(IOSIZE)     Else, store size in IOSIZE
000031F2                          2813  
000031F2                          2814          * Dest EA field: "Only data alterable addressing modes can be used [...]."
000031F2  303C 01FD               2815          MOVE.W  #M_DALT,D0      Set data alterable modes as valid
000031F6  6100 F77E               2816          BSR     EXSRC           Extract destination from source location
000031FA  6100 F5B0               2817          BSR     TSTAM           Test modes for validity
000031FE  6600 E4D4               2818          BNE     FLAGCL          If not valid, return unsuccessful
00003202  6100 F5D0               2819          BSR     ADVBFR          Else, advance the buffer accordingly
00003206                          2820          * The destination is in the source values, but this is ok because they are
00003206                          2821          * only used for display purposes and the order of values.
00003206  6000 E4C6               2822          BRA     FLAGST          Return successful
0000320A                          2823  
0000320A                          2824  * RTS: 0100111001110101
0000320A                          2825  * Syntax: RTS
0000320A                          2826  
0000320A  11FC 0083 10A8          2827  BRRTS   MOVE.B  #$83,(IOOPCD)   Set OP-code name
00003210  6000 E4BC               2828          BRA     FLAGST          Return successful
00003214                          2829  
00003214                          2830  * RTE: 0100111001110011
00003214                          2831  * Syntax: RTE
00003214                          2832  
00003214  11FC 00DD 10A8          2833  BRRTE   MOVE.B  #$DD,(IOOPCD)   Set OP-code name
0000321A  6000 E4B2               2834          BRA     FLAGST          Return successful
0000321E                          2835  
0000321E                          2836  * RTD: 0100111001110100
0000321E                          2837  * Syntax: RTD
0000321E                          2838  
0000321E  11FC 00E1 10A8          2839  BRRTD   MOVE.B  #$E1,(IOOPCD)   Set OP-code name
00003224  6000 E4A8               2840          BRA     FLAGST          Return successful
00003228                          2841  
00003228                          2842  * RTR: 0100111001110111
00003228                          2843  * Syntax: RTR
00003228                          2844  
00003228  11FC 00E5 10A8          2845  BRRTR   MOVE.B  #$E5,(IOOPCD)   Set OP-code name
0000322E  6000 E49E               2846          BRA     FLAGST          Return successful
00003232                          2847  
00003232                          2848  * NOP: 0100111001110001
00003232                          2849  * Syntax: NOP
00003232                          2850  
00003232  11FC 00E9 10A8          2851  BRNOP   MOVE.B  #$E9,(IOOPCD)   Set OP-code name
00003238  6000 E494               2852          BRA     FLAGST          Return successful
0000323C                          2853  
0000323C                          2854  * ILLEGAL: 0100101011111100
0000323C                          2855  * Syntax: ILLEGAL
0000323C                          2856  
0000323C                          2857  BRILLEGAL
0000323C  11FC 00FA 10A8          2858          MOVE.B  #$FA,(IOOPCD)   Set OP-code name
00003242  6000 E48A               2859          BRA     FLAGST          Return successful
00003246                          2860  
00003246                          2861          END     START

No errors detected
No warnings generated


SYMBOL TABLE INFORMATION
Symbol-name         Value
-------------------------
A2H                 170C
A2H11               1744
A2H12               174A
A2H13               1750
A2H14               1756
A2H15               175C
A2H16               1762
A2HADV              173C
ADVBFR              27D4
ADVBSZ              282E
ASCII2HEX           16DA
BADADV              2218
BCCTBL              2D42
BEXTW               1AD4
BLANK               1663
BRADD               2AB2
BRADDA              2AFE
BRADDI              2A94
BRADDQ              2B2A
BRAND               2BB6
BRANDI              2A80
BRARMQ              29CA
BRARW               31B0
BRASD               308A
BRBAD               21FE
BRBCC               2DC2
BRBCCD              2CF4
BRBCS               2DCC
BRBEQ               2D86
BRBGE               2DFE
BRBGT               2E08
BRBHI               2DA4
BRBLE               2E12
BRBLS               2E1C
BRBLT               2D90
BRBMI               2DF4
BRBNE               2D9A
BRBPL               2DEA
BRBRA               2DAE
BRBSR               2DB8
BRBTST              2C4E
BRBTSTD             2CBE
BRBTSTS             2C70
BRBVC               2DD6
BRBVS               2DE0
BRCMP               2E26
BRCMPA              2E60
BRCMPI              2AA8
BRDIVS              31A0
BRDIVU              3190
BREOR               2E8C
BREORI              2A9E
BRILLEGAL           323C
BRIMCCR             2A58
BRIMM               2A06
BRJMP               2F08
BRJSR               2EEA
BRLEA               2EC2
BRLSD               30BA
BRMOVE              2F26
BRMOVEA             2F9C
BRMOVEM             2FC8
BRMOVEQ             3064
BRMSD               314E
BRMULS              3180
BRMULU              3170
BRNOP               3232
BRNOT               31D4
BROR                2C02
BRORI               2A78
BRRSD               30EA
BRRTD               321E
BRRTE               3214
BRRTR               3228
BRRTS               320A
BRSUB               2B34
BRSUBA              2B80
BRSUBI              2A8A
BRSUBQ              2BAC
CHKEND              23BA
CLRRW               1928
CMPMSK              1810
CR                  D
D3BTBL              1E2C
DIS                 11C5
DISPADR             2126
DISPBD              2190
DISPC0              1E54
DISPC1              1E7E
DISPC2              1E9E
DISPC3              1EBE
DISPC4              1ED4
DISPC5              1EE8
DISPC6              1EFA
DISPC7              1F88
DISPC8              201E
DISPC9              2036
DISPDAT             229C
DISPDIS             1B62
DISPDST             2106
DISPINS             20B0
DISPM0              1C12
DISPM1              1C24
DISPM2              1C2C
DISPM3              1C44
DISPM4              1C62
DISPM5              1C80
DISPM6              1CB4
DISPM7              1D00
DISPM8              1E24
DISPM9              205A
DISPMA              206E
DISPMB              2082
DISPMC              2096
DISPOP              1BCE
DISPR0              1D20
DISPR1              1D3C
DISPR2              1D58
DISPR3              1D90
DISPR4              1DE0
DISPR5              1E12
DISPRAW             2156
DISPRT              20AA
DISPSRC             20E6
DISPSZ              20C4
DMD                 11C0
DMDTBL              1BDE
DONE                243A
DRG                 11C1
DRGTBL              1D08
DSPAN               1AA6
DSPAX               1856
DSPHADV             18B6
DSPHDR              240E
DSPHST              18A2
DSPHXA              1860
DSPHXB              1886
DSPHXL              18C0
DSPHXLP             1864
DSPHXRT             1880
DSPHXW              189A
DSPOFLP             190E
DSPOFRT             1922
DSPOFS              1904
DSPSP               1AC2
DSPSTLP             18D4
DSPSTR              18CA
DSPSTRT             18F0
ELOC                1054
ERR0                15E9
ERR1                1626
EXDST               2940
EXSRC               2976
EXTADV              1850
EXTLP               1844
EXTMSK              183E
FLAGCL              16D4
FLAGST              16CE
GBUFF               1000
H2A                 179A
H2AA                17D2
H2AADV              17CA
H2AB                17D8
H2AC                17DE
H2AD                17E4
H2AE                17EA
H2AF                17F0
HALT                2464
HEADR               1598
HEX2ASCII           1768
ILL0                1948
ILL1                1956
ILL2                1964
ILL3                19DA
ILL4                19E8
ILL5                19F2
IOADDR              10AC
IOBC                10B1
IOBDCD              10A9
IOLC                10B0
IOOPCD              10A8
IOOPSZ              11B4
IOSIZE              10AA
JMPMSK              2494
LF                  A
MASK                17F6
MLRADV              2004
MLRDEC              1FC6
MLRLP               1FA2
MLRNXT              200E
MNADDR              7000
MSSG0               11C6
MSSG1               1344
MSSG2               13B2
MSSG3               141C
MSSG4               1503
MSSG5               1547
MXADDR              FFFFFE
M_ALL               FFF
M_ALT               7F
M_CTR               7E4
M_DALT              1FD
M_DAT               FFD
M_EAALT             1FF
M_MALT              1FC
M_MEM               FFC
NEWBAD              225E
NEWLINE             21CC
NGBUFF              10A4
NOTBAD              22E2
OP                  24AC
OP0                 2898
OP1                 28AA
OP2                 28BC
OP3                 28CE
OP4                 28E0
OP5                 28F2
OP6                 2904
OP7                 2916
OP8                 2928
OPNAME              10B2
OPSIZE              2866
OPTBL               2878
PAUSE               23C8
PRINT               223E
PRINTD              2328
PRINTS              231A
PRMPT1              1982
PRMPT2              1A10
PRMPTDN             1A7A
PRNTFIN             2346
REQKEY              23D6
RESETIO             238E
RESTART             246A
RGMD                11C4
RLMADV              1F6E
RLMINC              1F32
RLMLP               1F12
RLMNXT              1F78
SC0                 1B16
SC1                 1B1E
SC2                 1B26
SC3                 1B2E
SC4                 1B36
SCTBL               1B06
SLOC                1004
SMD                 11C2
SRG                 11C3
START               16B4
SWAPF               29A4
TB                  9
TSTAM               27AC
TSTBAD              21E6
TSTMSK              17FC
